%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{tespackage}
\date{Sep 24, 2021}
\release{0.2.0}
\author{Leonardo Assis}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
Check out the {\hyperref[\detokenize{usage::doc}]{\sphinxcrossref{\DUrole{doc}{Usage}}}} section for further information, including how to
{\hyperref[\detokenize{usage:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{install}}}} the project.


\chapter{Contents}
\label{\detokenize{index:contents}}

\section{Usage}
\label{\detokenize{usage:usage}}\label{\detokenize{usage::doc}}
\sphinxAtStartPar
After downloading the files in this package to your computer, use the Jupyter notebooks on the folder ‘Jupyter Notebooks’ to use the package for:
\sphinxhyphen{} Configure the multi\sphinxhyphen{}channel analyser (MCA);
\sphinxhyphen{} Configure the measurements made by the hardware processor on the TES pulses;
\sphinxhyphen{} Calibrate the TES detectors;
\sphinxhyphen{} Transform area measurements in photon number information.

\sphinxAtStartPar
To use the package in your own programs/notebooks, import it using

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{import tes}
\end{sphinxVerbatim}


\subsection{Installation}
\label{\detokenize{usage:installation}}\label{\detokenize{usage:id1}}
\sphinxAtStartPar
We recommend that you create a virtual enviroment using conda to work and develop this package.

\sphinxAtStartPar
After downloading the contents of this repository to your machine, you can install the package using the terminal.

\sphinxAtStartPar
First open the folder where you installed the contents of this repository.

\sphinxAtStartPar
Then, install the package using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{python setup.py install}
\end{sphinxVerbatim}


\subsection{Requirements}
\label{\detokenize{usage:requirements}}
\sphinxAtStartPar
The tes package requires:
\begin{itemize}
\item {} 
\sphinxAtStartPar
numpy

\item {} 
\sphinxAtStartPar
scipy

\item {} 
\sphinxAtStartPar
matplotlib

\item {} 
\sphinxAtStartPar
numba

\item {} 
\sphinxAtStartPar
yaml

\item {} 
\sphinxAtStartPar
pyserial

\end{itemize}


\section{tes}
\label{\detokenize{modules:tes}}\label{\detokenize{modules::doc}}

\subsection{tes package}
\label{\detokenize{tes:tes-package}}\label{\detokenize{tes::doc}}

\subsubsection{Submodules}
\label{\detokenize{tes:submodules}}

\subsubsection{tes.analysis module}
\label{\detokenize{tes:module-tes.analysis}}\label{\detokenize{tes:tes-analysis-module}}\index{module@\spxentry{module}!tes.analysis@\spxentry{tes.analysis}}\index{tes.analysis@\spxentry{tes.analysis}!module@\spxentry{module}}
\sphinxAtStartPar
Module written by Dr. Geoff Gillet for calibration and modelling.

\sphinxAtStartPar
This module was kept as it was in previous version for backward compatibility.
\index{Counts (class in tes.analysis)@\spxentry{Counts}\spxextra{class in tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.Counts}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{Counts}}}{\emph{\DUrole{n}{count}}, \emph{\DUrole{n}{uncorrelated}}, \emph{\DUrole{n}{vacuum}}, \emph{\DUrole{n}{has\_noise\_threshold}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{tuple}}
\index{count (tes.analysis.Counts property)@\spxentry{count}\spxextra{tes.analysis.Counts property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.Counts.count}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{count}}}
\sphinxAtStartPar
Alias for field number 0

\end{fulllineitems}

\index{has\_noise\_threshold (tes.analysis.Counts property)@\spxentry{has\_noise\_threshold}\spxextra{tes.analysis.Counts property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.Counts.has_noise_threshold}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{has\_noise\_threshold}}}
\sphinxAtStartPar
Alias for field number 3

\end{fulllineitems}

\index{uncorrelated (tes.analysis.Counts property)@\spxentry{uncorrelated}\spxextra{tes.analysis.Counts property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.Counts.uncorrelated}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{uncorrelated}}}
\sphinxAtStartPar
Alias for field number 1

\end{fulllineitems}

\index{vacuum (tes.analysis.Counts property)@\spxentry{vacuum}\spxextra{tes.analysis.Counts property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.Counts.vacuum}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{vacuum}}}
\sphinxAtStartPar
Alias for field number 2

\end{fulllineitems}


\end{fulllineitems}

\index{Guess (class in tes.analysis)@\spxentry{Guess}\spxextra{class in tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.Guess}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{Guess}}}{\emph{\DUrole{n}{hist}}, \emph{\DUrole{n}{f}}, \emph{\DUrole{n}{bin\_c}}, \emph{\DUrole{n}{max\_i}}, \emph{\DUrole{n}{thresholds}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{tuple}}
\index{bin\_c (tes.analysis.Guess property)@\spxentry{bin\_c}\spxextra{tes.analysis.Guess property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.Guess.bin_c}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{bin\_c}}}
\sphinxAtStartPar
Alias for field number 2

\end{fulllineitems}

\index{f (tes.analysis.Guess property)@\spxentry{f}\spxextra{tes.analysis.Guess property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.Guess.f}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{f}}}
\sphinxAtStartPar
Alias for field number 1

\end{fulllineitems}

\index{hist (tes.analysis.Guess property)@\spxentry{hist}\spxextra{tes.analysis.Guess property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.Guess.hist}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{hist}}}
\sphinxAtStartPar
Alias for field number 0

\end{fulllineitems}

\index{max\_i (tes.analysis.Guess property)@\spxentry{max\_i}\spxextra{tes.analysis.Guess property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.Guess.max_i}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{max\_i}}}
\sphinxAtStartPar
Alias for field number 3

\end{fulllineitems}

\index{thresholds (tes.analysis.Guess property)@\spxentry{thresholds}\spxextra{tes.analysis.Guess property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.Guess.thresholds}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{thresholds}}}
\sphinxAtStartPar
Alias for field number 4

\end{fulllineitems}


\end{fulllineitems}

\index{MixtureModel (class in tes.analysis)@\spxentry{MixtureModel}\spxextra{class in tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.MixtureModel}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{MixtureModel}}}{\emph{\DUrole{n}{param\_list}}, \emph{\DUrole{n}{thresholds}}, \emph{\DUrole{n}{zero\_loc}}, \emph{\DUrole{n}{log\_likelihood}}, \emph{\DUrole{n}{converged}}, \emph{\DUrole{n}{dist}}, \emph{\DUrole{n}{has\_noise\_threshold}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{tes:tes.analysis.MixtureModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tes.analysis.MixtureModel}}}}}

\sphinxAtStartPar
Subclass of namedtuple used to represent a mixture model.
\begin{description}
\item[{fields:}] \leavevmode\begin{quote}\begin{description}
\item[{param\_list}] \leavevmode
\sphinxAtStartPar
list of parameters for each distribution in the mixture.

\item[{thresholds}] \leavevmode
\sphinxAtStartPar
the intersection of neighbouring distributions in the
mixture.

\item[{zero\_loc}] \leavevmode
\sphinxAtStartPar
Fixed location parameter used to fit the first distribution,
or None if the location parameter was fitted.

\item[{log\_likelihood}] \leavevmode
\sphinxAtStartPar
the log of the likelihood that the model could produce
the data used to construct it.

\item[{converged}] \leavevmode
\sphinxAtStartPar
boolean indicating that the expectation maximisation
algorithm terminated normally when fitting the model.

\item[{dist}] \leavevmode
\sphinxAtStartPar
the type of distribution forming the components of the mixture,
(see scipy.stats).

\end{description}\end{quote}

\end{description}
\index{cdf() (tes.analysis.MixtureModel method)@\spxentry{cdf()}\spxextra{tes.analysis.MixtureModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.MixtureModel.cdf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cdf}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{d}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{scale}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
evaluate the pdf(s) of the distribution(s) selected by d at x.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} value(s) where to the function is evaluated.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{d}} \textendash{} selects element(s) of param\_list that parameterise the
distributions. If None all distributions in param\_list are
used.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scale}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} when true return the scaled pdf, the scale is always
param{[}\sphinxhyphen{}1{]}.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
ndarray shape (len(d), len(x)) containing the pdf(s) or a
single value if only 1 point in 1 distribution is selected.

\end{description}\end{quote}

\end{fulllineitems}

\index{load() (tes.analysis.MixtureModel static method)@\spxentry{load()}\spxextra{tes.analysis.MixtureModel static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.MixtureModel.load}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{load}}}{\emph{\DUrole{n}{filename}}}{}
\sphinxAtStartPar
load model from .npz file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filename}} \textendash{} filename excluding extension”

\item[{Returns}] \leavevmode
\sphinxAtStartPar
instance of MixtureModel.

\end{description}\end{quote}

\end{fulllineitems}

\index{pdf() (tes.analysis.MixtureModel method)@\spxentry{pdf()}\spxextra{tes.analysis.MixtureModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.MixtureModel.pdf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pdf}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{d}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{scale}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
evaluate the pdf(s) of the distribution(s) selected by d at x.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} value(s) where to the function is evaluated.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{d}} \textendash{} selects element(s) of param\_list that parameterise the
distributions. If None all distributions in param\_list are
used.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scale}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} when true return the scaled pdf, the scale is always
param{[}\sphinxhyphen{}1{]}.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
ndarray shape (len(d), len(x)) containing the pdf(s) or a
single value if only 1 point in 1 distribution is selected.

\end{description}\end{quote}

\end{fulllineitems}

\index{save() (tes.analysis.MixtureModel method)@\spxentry{save()}\spxextra{tes.analysis.MixtureModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.MixtureModel.save}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{filename}}}{}
\sphinxAtStartPar
save model as .npz file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filename}} \textendash{} filename to save as, excluding extension”

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Povm (in module tes.analysis)@\spxentry{Povm}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.Povm}}\pysigline{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{Povm}}}
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{tes.analysis.povm}}

\end{fulllineitems}

\index{coherent\_ml() (in module tes.analysis)@\spxentry{coherent\_ml()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.coherent_ml}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{coherent\_ml}}}{\emph{\DUrole{n}{counts}}, \emph{\DUrole{n}{povm}}, \emph{\DUrole{n}{max\_photon\_number}}, \emph{\DUrole{n}{x0}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\end{fulllineitems}

\index{coherent\_neg\_ll() (in module tes.analysis)@\spxentry{coherent\_neg\_ll()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.coherent_neg_ll}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{coherent\_neg\_ll}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{counts}}, \emph{\DUrole{n}{povm}}, \emph{\DUrole{n}{max\_photon\_number}}}{}
\end{fulllineitems}

\index{coincidence() (in module tes.analysis)@\spxentry{coincidence()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.coincidence}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{coincidence}}}{\emph{\DUrole{n}{abs\_time}}, \emph{\DUrole{n}{mask}}, \emph{\DUrole{n}{low}}, \emph{\DUrole{n}{high}}}{}
\sphinxAtStartPar
Find coincidences between two channels returning indices of partner events.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{abs\_time}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} absolute times.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} ndarray of bool that identifies the channels in
abs\_time. For abs\_times where mask is False, time t is
coincident if abs\_time+low \textless{}= t \textless{}= abs\_time+high. If
the mask is True t is coincident if
abs\_time\sphinxhyphen{}high \textless{}= t \textless{}= abs\_time\sphinxhyphen{}low.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{low}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the low side of the coincidence window.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{high}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the high side of the coincidence whindw.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
(coinc, coinc\_mask) where coinc is a ndarray of indices of the
coincident event in the other channel. When more than one event is
found in the window the negated value of the first index is
entered.
coinc\_mask is a ndarray of bool indicating where exactly one
event was found in the window.

\end{description}\end{quote}

\end{fulllineitems}

\index{count() (in module tes.analysis)@\spxentry{count()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.count}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{count}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{measurement\_model}}, \emph{\DUrole{n}{vacuum}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{has\_noise\_threshold}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{coinc\_mask}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{herald\_mask}\DUrole{o}{=}\DUrole{default_value}{None}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} measurement data.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{measurement\_model}} ({\hyperref[\detokenize{tes:tes.analysis.MixtureModel}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{MixtureModel}}}}}) \textendash{} model created using
expectation\_maximisation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{vacuum}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} estimate vacuum terms using coinc\_mask and herald\_mask.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coinc\_mask}} \textendash{} ndarray of bool indicating coincidence.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{herald\_mask}} \textendash{} ndarray of bool indicating which events are in the
heralding channel.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{has\_noise\_threshold}} \textendash{} When True model.thresholds{[}1{]} represents the
boundary between noise and 1 photon.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Counts(count, uncorrelated, vacuum). Where count is an ndarray of
counts for each photon number
and len(count)=len(measurement\_model.thresholds). uncorrelated is a
ndarray the same shape as count and counts
events not correlated with the herald. uncorrelated is only
calculated when coinc\_mask and herald\_mask are supplied.
vacuum replicates the parameter value and indicates that count{[}0{]}
contains the vacuum count.

\end{description}\end{quote}

\end{fulllineitems}

\index{displaced\_thermal() (in module tes.analysis)@\spxentry{displaced\_thermal()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.displaced_thermal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{displaced\_thermal}}}{\emph{\DUrole{n}{max\_photon\_number}}, \emph{\DUrole{n}{nbar}}, \emph{\DUrole{n}{alpha}}, \emph{\DUrole{n}{N}\DUrole{o}{=}\DUrole{default_value}{200}}}{}
\end{fulllineitems}

\index{displaced\_vacuum() (in module tes.analysis)@\spxentry{displaced\_vacuum()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.displaced_vacuum}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{displaced\_vacuum}}}{\emph{\DUrole{n}{max\_photon\_number}}, \emph{\DUrole{n}{alpha}}, \emph{\DUrole{n}{N}\DUrole{o}{=}\DUrole{default_value}{200}}}{}
\end{fulllineitems}

\index{drive\_correlation() (in module tes.analysis)@\spxentry{drive\_correlation()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.drive_correlation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{drive\_correlation}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{model}}, \emph{\DUrole{n}{abs\_time}}, \emph{\DUrole{n}{detection\_mask}}, \emph{\DUrole{n}{r}}, \emph{\DUrole{n}{last\_threshold}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}, \emph{\DUrole{n}{masks}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Calculate the temporal cross\sphinxhyphen{}correlation between a channel measuring a
heralding signal, ie the laser drive pulse, and a channel detecting photons.
The correlation is calculated for the different photon numbers determined by
the thresholds parameter.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{abs\_time}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} absolute timestamp sequence.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{detection\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} boolean mask that identifies the entries in
abs\_time belonging to the photon channel,
other entries are assumed to be the heralding
channel.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} energy measurement data for the photon channel.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{masks}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} boolean masks that are appied to
abs\_time{[}detection\_mask{]} and indicate which detections
are assigned which threshold.
Shape(N, len(abs\_time{[}detection\_mask{]}))

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{r}} \textendash{} the range of heralding channel delays to cross correlate.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Print progress message as each threshold is processed.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
list of ndarrays representing the cross correlation.

\item[{Note}] \leavevmode
\sphinxAtStartPar
abs\_time{[}mask{]} and data must be the same length.
TODO speed up the algorithm.

\end{description}\end{quote}

\end{fulllineitems}

\index{expectation\_maximisation() (in module tes.analysis)@\spxentry{expectation\_maximisation()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.expectation_maximisation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{expectation\_maximisation}}}{\emph{data}, \emph{initial\_thresholds}, \emph{has\_noise\_threshold=False}, \emph{dist=\textless{}scipy.stats.\_continuous\_distns.gamma\_gen object\textgreater{}}, \emph{tol=0.01}, \emph{max\_iter=30}, \emph{verbose=True}}{}
\sphinxAtStartPar
Fit a mixture of distributions to data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} the measurement data.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{initial\_thresholds}} \textendash{} initial thresholds that divide data into
individual distributions in the mixture.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fix\_noise}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} When True keep threshold{[}1{]} fixed.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dist}} \textendash{} the type of distribution to use (see scipy.stats)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tol}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} termination tolerance for change in log\_likelihood.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_iter}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} max iterations of expectation maximisation to use.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} print progress during optimisation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{normalise}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} passed to maximise step, thresholds are calculated
using the intersection of the normalised distributions.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
(param\_list, zero\_loc, log\_likelihood, converged) as a named tuple.
Where param\_list is a list of parameter values for distribution in
the mixture, zero\_loc is the arg used to fit, log\_likelihood is the
log\_likelihood of the fit, converged is a bool indicating normal
termination.

\item[{Note}] \leavevmode
\sphinxAtStartPar
Uses The Expectation maximisation algorithm with hard assignment of
responsibilities.

\end{description}\end{quote}

\end{fulllineitems}

\index{fit\_state\_least\_squares() (in module tes.analysis)@\spxentry{fit\_state\_least\_squares()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.fit_state_least_squares}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{fit\_state\_least\_squares}}}{\emph{\DUrole{n}{counts}}, \emph{\DUrole{n}{povm}}, \emph{\DUrole{n}{max\_outcome}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{vacuum}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{thermal}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{N}\DUrole{o}{=}\DUrole{default_value}{150}}}{}
\end{fulllineitems}

\index{guess\_thresholds() (in module tes.analysis)@\spxentry{guess\_thresholds()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.guess_thresholds}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{guess\_thresholds}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{bins}\DUrole{o}{=}\DUrole{default_value}{16000}}, \emph{\DUrole{n}{win\_length}\DUrole{o}{=}\DUrole{default_value}{200}}, \emph{\DUrole{n}{maxima\_threshold}\DUrole{o}{=}\DUrole{default_value}{10}}}{}
\sphinxAtStartPar
Guess the photon number thresholds using a smoothed histogram.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} the measurement data.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bins}} \textendash{} argument to numpy.histogram.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{win\_length}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Hanning window length used for smoothing.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{maxima\_threshold}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} passed to maxima function.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
(hist, f, bin\_c, max\_i, thresholds) as a named
tuple. Where hist is the histogram
generated by np.histogram(), f is the smoothed histogram, bin\_c is a
ndarray of bin centers, max\_i are the indices of the maxima in f,
and thresholds is a ndarray of threshold guesses.

\item[{Notes}] \leavevmode
\sphinxAtStartPar
The smoothing is achieved by convolving the Hanning window with a
histogram generated using numpy.histogram. The guess still needs
some human sanity checks, especially multiple maxima per photon
peak. Use plot\_guess() and adjust window and maxima\_threshold to
remove them.

\end{description}\end{quote}

\end{fulllineitems}

\index{hard\_expectation() (in module tes.analysis)@\spxentry{hard\_expectation()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.hard_expectation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{hard\_expectation}}}{\emph{param\_list}, \emph{fix\_noise=None}, \emph{normalise=False}, \emph{dist=\textless{}scipy.stats.\_continuous\_distns.gamma\_gen object\textgreater{}}}{}
\sphinxAtStartPar
Calculate the thresholds for a mixture model that define the data
partitions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{param\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of parameters for the distributions in the
mixture model, returned by expectation\_maximisation().

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fix\_noise}} \textendash{} Fix threshold{[}1{]} at this value.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{normalise}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} calculate thresholds based on a mixture of
normalised pdf’s.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dist}} \textendash{} type of distribution

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
ndarray of threshold values.

\end{description}\end{quote}

\end{fulllineitems}

\index{hard\_maximisation() (in module tes.analysis)@\spxentry{hard\_maximisation()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.hard_maximisation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{hard\_maximisation}}}{\emph{data}, \emph{thresholds}, \emph{dist=\textless{}scipy.stats.\_continuous\_distns.gamma\_gen object\textgreater{}}, \emph{verbose=True}, \emph{has\_noise\_threshold=False}}{}
\sphinxAtStartPar
Fit distributions to the data partitioned by thresholds.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} the data to model.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{thresholds}} \textendash{} thresholds that divide data into separate distributions.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dist}} \textendash{} type of distribution to fit (scipy.stats).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Print fitted distribution parameters.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
list of parameters for each distribution.

\end{description}\end{quote}

\end{fulllineitems}

\index{maxima() (in module tes.analysis)@\spxentry{maxima()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.maxima}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{maxima}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{thresh}\DUrole{o}{=}\DUrole{default_value}{10}}}{}
\sphinxAtStartPar
Find local maxima of f using rising zero crossings of the gradient of f.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{f}} \textendash{} function to find maxima for

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{thresh}} \textendash{} Only return a maxima if f{[}maxima{]}\textgreater{}thresh

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
array of maxima.

\item[{Notes}] \leavevmode
\sphinxAtStartPar
Used to find the maxima of the smoothed measurement histogram.

\end{description}\end{quote}

\end{fulllineitems}

\index{mixture\_model\_ll() (in module tes.analysis)@\spxentry{mixture\_model\_ll()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.mixture_model_ll}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{mixture\_model\_ll}}}{\emph{data}, \emph{param\_list}, \emph{has\_noise\_threshold=False}, \emph{dist=\textless{}scipy.stats.\_continuous\_distns.gamma\_gen object\textgreater{}}}{}
\sphinxAtStartPar
Calculate the log likelihood of a mixture model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} the data used to construct the model.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{param\_list}} \textendash{} list of parameters for each distribution in the model.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dist}} \textendash{} the type of distribution to use (see scipy.stats).

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the log likelihood.

\end{description}\end{quote}

\end{fulllineitems}

\index{normalised\_pdf() (in module tes.analysis)@\spxentry{normalised\_pdf()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.normalised_pdf}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{normalised\_pdf}}}{\emph{x}, \emph{params}, \emph{dist=\textless{}scipy.stats.\_continuous\_distns.gamma\_gen object\textgreater{}}}{}
\sphinxAtStartPar
Convenience function, calculate normalised pdf at each x for dist.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} calculate the pdf a each x

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}) \textendash{} fitted distribution parameters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dist}} \textendash{} type of distribution (see scipy.stats)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
ndarray containing pdf(x)

\end{description}\end{quote}

\end{fulllineitems}

\index{outcome\_probabilities() (in module tes.analysis)@\spxentry{outcome\_probabilities()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.outcome_probabilities}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{outcome\_probabilities}}}{\emph{\DUrole{n}{state}}, \emph{\DUrole{n}{povm}}, \emph{\DUrole{n}{max\_photon\_number}}}{}
\end{fulllineitems}

\index{partition() (in module tes.analysis)@\spxentry{partition()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.partition}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{partition}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{thresholds}}, \emph{\DUrole{n}{i}}}{}
\sphinxAtStartPar
Return the ith partition of the data as defined by thresholds.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} the data to partition.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{thresholds}} (\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}) \textendash{} the threshold values that partition data.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{i}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} the partition to return, the ith partition is defined as
threshold{[}i{]} \textless{} data \textless{}= threshold{[}i+1{]}. The last partition,
when i = len(thresholds\sphinxhyphen{}1), is defined as

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
ndarray of the data in the partition.

\item[{Note}] \leavevmode
\sphinxAtStartPar
This is used to assign a hard responsibility in the expectation
maximisation algorithm used to fit data to a mixture model.

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_guess() (in module tes.analysis)@\spxentry{plot\_guess()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.plot_guess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{plot\_guess}}}{\emph{\DUrole{n}{hist}}, \emph{\DUrole{n}{f}}, \emph{\DUrole{n}{x}}, \emph{\DUrole{n}{max\_i}}, \emph{\DUrole{n}{init\_t}}, \emph{\DUrole{n}{figsize}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{measurement\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textbackslash{}\textbackslash{}texttt\{area\}\textquotesingle{}}}}{}
\end{fulllineitems}

\index{plot\_mixture\_model() (in module tes.analysis)@\spxentry{plot\_mixture\_model()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.plot_mixture_model}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{plot\_mixture\_model}}}{\emph{\DUrole{n}{model}}, \emph{\DUrole{n}{vacuum}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{counts}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{xrange}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{normalised}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{bins}\DUrole{o}{=}\DUrole{default_value}{500}}, \emph{\DUrole{n}{bar}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{measurement\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textbackslash{}\textbackslash{}texttt\{area\}\textquotesingle{}}}, \emph{\DUrole{n}{last\_threshold}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{figsize}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Plot a mixture model optionally including a histogram of the modeled data.
if no data is None x must not be None.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{model}} ({\hyperref[\detokenize{tes:tes.analysis.MixtureModel}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{MixtureModel}}}}}) \textendash{} the mixture model.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} the data to histogram.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{xrange}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}) \textendash{} the x range to plot.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{normalised}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} normalise the model distributions.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bins}} \textendash{} passed to numpy.histogram().

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bar}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Plot bars instead of markers.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{figsize}} \textendash{} passed to matplotlib.pyplot.figure().

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the figure handle.

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_state\_fit() (in module tes.analysis)@\spxentry{plot\_state\_fit()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.plot_state_fit}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{plot\_state\_fit}}}{\emph{\DUrole{n}{nbar}}, \emph{\DUrole{n}{alpha}}, \emph{\DUrole{n}{counts}}, \emph{\DUrole{n}{povm}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{figsize}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\end{fulllineitems}

\index{povm\_elements() (in module tes.analysis)@\spxentry{povm\_elements()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.povm_elements}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{povm\_elements}}}{\emph{\DUrole{n}{measurement\_model}}, \emph{\DUrole{n}{counts}}}{}
\sphinxAtStartPar
estimate the elements of the system povm from the measurement model and the
counting data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{array like}}) \textendash{} measurement data.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{measurement\_model}} (\sphinxstyleliteralemphasis{\sphinxupquote{mixturemodel}}) \textendash{} model created using
expectation\_maximisation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{counts}} ({\hyperref[\detokenize{tes:tes.analysis.Counts}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Counts}}}}}) \textendash{} the count data returned by count().

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
(elements count vacuum). where counts is a ndarray with
shape (len(n)) containing the count for each measurement outcome
in n. elements is a ndarray with
shape(len(n), len(measurement\_model.thresholds)) the first index is
the fock state, the second is the outcome. The contents of elements
is the probability of the outcome when measuring fock state.

\item[{Notes}] \leavevmode
\sphinxAtStartPar
POVM elements is indexed by (fock state, measurement outcome).
The last threshold in the measurement model marks the boundary of
the data that was used to create the model, it is \sphinxstyleemphasis{not} altered by
the expectation maximisation algorithm and is essentially a guess.
The second last threshold is the boundary of the overflow bin,
this last photon number bin is counts detections of \textgreater{}=
len(measurement\_model.param\_list)\sphinxhyphen{}2 photons.
TODO expand and clarify description.

\end{description}\end{quote}

\end{fulllineitems}

\index{resize\_vector() (in module tes.analysis)@\spxentry{resize\_vector()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.resize_vector}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{resize\_vector}}}{\emph{\DUrole{n}{a}}, \emph{\DUrole{n}{max\_index}}, \emph{\DUrole{n}{copy}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\end{fulllineitems}

\index{retime() (in module tes.analysis)@\spxentry{retime()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.retime}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{retime}}}{\emph{\DUrole{n}{events}}, \emph{\DUrole{n}{tdat}}, \emph{\DUrole{n}{fidx}}, \emph{\DUrole{n}{tidx}}}{}
\end{fulllineitems}

\index{scaled\_pdf() (in module tes.analysis)@\spxentry{scaled\_pdf()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.scaled_pdf}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{scaled\_pdf}}}{\emph{x}, \emph{params}, \emph{dist=\textless{}scipy.stats.\_continuous\_distns.gamma\_gen object\textgreater{}}}{}
\sphinxAtStartPar
Convenience function, calculate pdf at each x for dist, normalisation is
given by params{[}\sphinxhyphen{}1{]}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} calculate the pdf a each x

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}) \textendash{} fitted distribution parameters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dist}} \textendash{} type of distribution (see scipy.stats)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
ndarray containing pdf(x)

\end{description}\end{quote}

\end{fulllineitems}

\index{thermal\_ml() (in module tes.analysis)@\spxentry{thermal\_ml()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.thermal_ml}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{thermal\_ml}}}{\emph{\DUrole{n}{counts}}, \emph{\DUrole{n}{povm}}, \emph{\DUrole{n}{max\_photon\_number}}, \emph{\DUrole{n}{x0}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\end{fulllineitems}

\index{thermal\_neg\_ll() (in module tes.analysis)@\spxentry{thermal\_neg\_ll()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.thermal_neg_ll}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{thermal\_neg\_ll}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{counts}}, \emph{\DUrole{n}{povm}}, \emph{\DUrole{n}{max\_photon\_number}}}{}
\end{fulllineitems}

\index{threshold\_masks() (in module tes.analysis)@\spxentry{threshold\_masks()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.threshold_masks}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{threshold\_masks}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{model}}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{model}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{window() (in module tes.analysis)@\spxentry{window()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.window}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{window}}}{\emph{\DUrole{n}{i}}, \emph{\DUrole{n}{abs\_time}}, \emph{\DUrole{n}{low}}, \emph{\DUrole{n}{high}}}{}
\sphinxAtStartPar
get offsets from the current index i in abs\_time that are in the relative
time window defined by low and high.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{i}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} current abs\_time index.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{abs\_time}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} absolute times.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{low}} \textendash{} low end of relative window.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{high}} \textendash{} high end of relative window.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
(low\_o, high\_o) coincident times are abs\_time{[}low\_o:i+high\_o{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{x\_correlation() (in module tes.analysis)@\spxentry{x\_correlation()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.x_correlation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{x\_correlation}}}{\emph{\DUrole{n}{s1}}, \emph{\DUrole{n}{s2}}, \emph{\DUrole{n}{r}}}{}
\sphinxAtStartPar
Cross correlation of timestamp sequences s1 and s2 over the delay range r.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s1}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} Monotonically increasing timestamp sequence.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s2}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} Monotonically increasing timestamp sequence.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{r}} \textendash{} range of delays added to s1

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
ndarray representing the cross correlation function.

\end{description}\end{quote}

\end{fulllineitems}

\index{xcor() (in module tes.analysis)@\spxentry{xcor()}\spxextra{in module tes.analysis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.analysis.xcor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.analysis.}}\sphinxbfcode{\sphinxupquote{xcor}}}{\emph{\DUrole{n}{s1}}, \emph{\DUrole{n}{s2}}}{}
\sphinxAtStartPar
Count correlations between timestamp sequences.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s1}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} Monotonically increasing timestamp sequence.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s2}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} Monotonically increasing timestamp sequence.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
correlation count.

\item[{Notes}] \leavevmode
\sphinxAtStartPar
iterates over s1 and performs a linear search of  s2 for the s1
timestamp.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{tes.base module}
\label{\detokenize{tes:module-tes.base}}\label{\detokenize{tes:tes-base-module}}\index{module@\spxentry{module}!tes.base@\spxentry{tes.base}}\index{tes.base@\spxentry{tes.base}!module@\spxentry{module}}
\sphinxAtStartPar
Classes:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
VhdlEnum

\item {} 
\sphinxAtStartPar
TraceType

\item {} 
\sphinxAtStartPar
Signal

\item {} 
\sphinxAtStartPar
Height

\item {} 
\sphinxAtStartPar
Timing

\item {} 
\sphinxAtStartPar
detection

\item {} 
\sphinxAtStartPar
Payload

\item {} 
\sphinxAtStartPar
lookup

\end{enumerate}

\sphinxAtStartPar
Function:
1) pulse\_fmt
\index{Detection (class in tes.base)@\spxentry{Detection}\spxextra{class in tes.base}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Detection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.base.}}\sphinxbfcode{\sphinxupquote{Detection}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{tes:tes.base.VhdlEnum}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tes.base.VhdlEnum}}}}}

\sphinxAtStartPar
Value of the event.packet register.
\index{area (tes.base.Detection attribute)@\spxentry{area}\spxextra{tes.base.Detection attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Detection.area}}\pysigline{\sphinxbfcode{\sphinxupquote{area}}\sphinxbfcode{\sphinxupquote{ = 1}}}
\end{fulllineitems}

\index{pulse (tes.base.Detection attribute)@\spxentry{pulse}\spxextra{tes.base.Detection attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Detection.pulse}}\pysigline{\sphinxbfcode{\sphinxupquote{pulse}}\sphinxbfcode{\sphinxupquote{ = 2}}}
\end{fulllineitems}

\index{rise (tes.base.Detection attribute)@\spxentry{rise}\spxextra{tes.base.Detection attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Detection.rise}}\pysigline{\sphinxbfcode{\sphinxupquote{rise}}\sphinxbfcode{\sphinxupquote{ = 0}}}
\end{fulllineitems}

\index{trace (tes.base.Detection attribute)@\spxentry{trace}\spxextra{tes.base.Detection attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Detection.trace}}\pysigline{\sphinxbfcode{\sphinxupquote{trace}}\sphinxbfcode{\sphinxupquote{ = 3}}}
\end{fulllineitems}


\end{fulllineitems}

\index{Height (class in tes.base)@\spxentry{Height}\spxextra{class in tes.base}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Height}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.base.}}\sphinxbfcode{\sphinxupquote{Height}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{tes:tes.base.VhdlEnum}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tes.base.VhdlEnum}}}}}

\sphinxAtStartPar
Value of the event.height register.
\index{cfd\_height (tes.base.Height attribute)@\spxentry{cfd\_height}\spxextra{tes.base.Height attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Height.cfd_height}}\pysigline{\sphinxbfcode{\sphinxupquote{cfd\_height}}\sphinxbfcode{\sphinxupquote{ = 2}}}
\end{fulllineitems}

\index{cfd\_high (tes.base.Height attribute)@\spxentry{cfd\_high}\spxextra{tes.base.Height attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Height.cfd_high}}\pysigline{\sphinxbfcode{\sphinxupquote{cfd\_high}}\sphinxbfcode{\sphinxupquote{ = 1}}}
\end{fulllineitems}

\index{max\_slope (tes.base.Height attribute)@\spxentry{max\_slope}\spxextra{tes.base.Height attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Height.max_slope}}\pysigline{\sphinxbfcode{\sphinxupquote{max\_slope}}\sphinxbfcode{\sphinxupquote{ = 3}}}
\end{fulllineitems}

\index{peak (tes.base.Height attribute)@\spxentry{peak}\spxextra{tes.base.Height attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Height.peak}}\pysigline{\sphinxbfcode{\sphinxupquote{peak}}\sphinxbfcode{\sphinxupquote{ = 0}}}
\end{fulllineitems}


\end{fulllineitems}

\index{Payload (class in tes.base)@\spxentry{Payload}\spxextra{class in tes.base}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Payload}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.base.}}\sphinxbfcode{\sphinxupquote{Payload}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{tes:tes.base.VhdlEnum}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tes.base.VhdlEnum}}}}}

\sphinxAtStartPar
Payload type in capture files.
\index{area (tes.base.Payload attribute)@\spxentry{area}\spxextra{tes.base.Payload attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Payload.area}}\pysigline{\sphinxbfcode{\sphinxupquote{area}}\sphinxbfcode{\sphinxupquote{ = 1}}}
\end{fulllineitems}

\index{average\_trace (tes.base.Payload attribute)@\spxentry{average\_trace}\spxextra{tes.base.Payload attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Payload.average_trace}}\pysigline{\sphinxbfcode{\sphinxupquote{average\_trace}}\sphinxbfcode{\sphinxupquote{ = 4}}}
\end{fulllineitems}

\index{bad\_frame (tes.base.Payload attribute)@\spxentry{bad\_frame}\spxextra{tes.base.Payload attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Payload.bad_frame}}\pysigline{\sphinxbfcode{\sphinxupquote{bad\_frame}}\sphinxbfcode{\sphinxupquote{ = 9}}}
\end{fulllineitems}

\index{dot\_product (tes.base.Payload attribute)@\spxentry{dot\_product}\spxextra{tes.base.Payload attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Payload.dot_product}}\pysigline{\sphinxbfcode{\sphinxupquote{dot\_product}}\sphinxbfcode{\sphinxupquote{ = 5}}}
\end{fulllineitems}

\index{dot\_product\_trace (tes.base.Payload attribute)@\spxentry{dot\_product\_trace}\spxextra{tes.base.Payload attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Payload.dot_product_trace}}\pysigline{\sphinxbfcode{\sphinxupquote{dot\_product\_trace}}\sphinxbfcode{\sphinxupquote{ = 6}}}
\end{fulllineitems}

\index{mca (tes.base.Payload attribute)@\spxentry{mca}\spxextra{tes.base.Payload attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Payload.mca}}\pysigline{\sphinxbfcode{\sphinxupquote{mca}}\sphinxbfcode{\sphinxupquote{ = 8}}}
\end{fulllineitems}

\index{pulse (tes.base.Payload attribute)@\spxentry{pulse}\spxextra{tes.base.Payload attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Payload.pulse}}\pysigline{\sphinxbfcode{\sphinxupquote{pulse}}\sphinxbfcode{\sphinxupquote{ = 2}}}
\end{fulllineitems}

\index{rise (tes.base.Payload attribute)@\spxentry{rise}\spxextra{tes.base.Payload attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Payload.rise}}\pysigline{\sphinxbfcode{\sphinxupquote{rise}}\sphinxbfcode{\sphinxupquote{ = 0}}}
\end{fulllineitems}

\index{single\_trace (tes.base.Payload attribute)@\spxentry{single\_trace}\spxextra{tes.base.Payload attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Payload.single_trace}}\pysigline{\sphinxbfcode{\sphinxupquote{single\_trace}}\sphinxbfcode{\sphinxupquote{ = 3}}}
\end{fulllineitems}

\index{tick (tes.base.Payload attribute)@\spxentry{tick}\spxextra{tes.base.Payload attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Payload.tick}}\pysigline{\sphinxbfcode{\sphinxupquote{tick}}\sphinxbfcode{\sphinxupquote{ = 7}}}
\end{fulllineitems}


\end{fulllineitems}

\index{Signal (class in tes.base)@\spxentry{Signal}\spxextra{class in tes.base}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Signal}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.base.}}\sphinxbfcode{\sphinxupquote{Signal}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{tes:tes.base.VhdlEnum}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tes.base.VhdlEnum}}}}}

\sphinxAtStartPar
The signal recorded in a trace.
\index{f (tes.base.Signal attribute)@\spxentry{f}\spxextra{tes.base.Signal attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Signal.f}}\pysigline{\sphinxbfcode{\sphinxupquote{f}}\sphinxbfcode{\sphinxupquote{ = 2}}}
\end{fulllineitems}

\index{none (tes.base.Signal attribute)@\spxentry{none}\spxextra{tes.base.Signal attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Signal.none}}\pysigline{\sphinxbfcode{\sphinxupquote{none}}\sphinxbfcode{\sphinxupquote{ = 0}}}
\end{fulllineitems}

\index{raw (tes.base.Signal attribute)@\spxentry{raw}\spxextra{tes.base.Signal attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Signal.raw}}\pysigline{\sphinxbfcode{\sphinxupquote{raw}}\sphinxbfcode{\sphinxupquote{ = 1}}}
\end{fulllineitems}

\index{s (tes.base.Signal attribute)@\spxentry{s}\spxextra{tes.base.Signal attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Signal.s}}\pysigline{\sphinxbfcode{\sphinxupquote{s}}\sphinxbfcode{\sphinxupquote{ = 3}}}
\end{fulllineitems}


\end{fulllineitems}

\index{Timing (class in tes.base)@\spxentry{Timing}\spxextra{class in tes.base}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Timing}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.base.}}\sphinxbfcode{\sphinxupquote{Timing}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{tes:tes.base.VhdlEnum}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tes.base.VhdlEnum}}}}}

\sphinxAtStartPar
Value of the event.timing register.
\index{cfd\_low (tes.base.Timing attribute)@\spxentry{cfd\_low}\spxextra{tes.base.Timing attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Timing.cfd_low}}\pysigline{\sphinxbfcode{\sphinxupquote{cfd\_low}}\sphinxbfcode{\sphinxupquote{ = 2}}}
\end{fulllineitems}

\index{max\_slope (tes.base.Timing attribute)@\spxentry{max\_slope}\spxextra{tes.base.Timing attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Timing.max_slope}}\pysigline{\sphinxbfcode{\sphinxupquote{max\_slope}}\sphinxbfcode{\sphinxupquote{ = 3}}}
\end{fulllineitems}

\index{pulse\_threshold (tes.base.Timing attribute)@\spxentry{pulse\_threshold}\spxextra{tes.base.Timing attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Timing.pulse_threshold}}\pysigline{\sphinxbfcode{\sphinxupquote{pulse\_threshold}}\sphinxbfcode{\sphinxupquote{ = 0}}}
\end{fulllineitems}

\index{slope\_threshold (tes.base.Timing attribute)@\spxentry{slope\_threshold}\spxextra{tes.base.Timing attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.Timing.slope_threshold}}\pysigline{\sphinxbfcode{\sphinxupquote{slope\_threshold}}\sphinxbfcode{\sphinxupquote{ = 1}}}
\end{fulllineitems}


\end{fulllineitems}

\index{TraceType (class in tes.base)@\spxentry{TraceType}\spxextra{class in tes.base}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.TraceType}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.base.}}\sphinxbfcode{\sphinxupquote{TraceType}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{tes:tes.base.VhdlEnum}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tes.base.VhdlEnum}}}}}

\sphinxAtStartPar
Value of the trace\_type event.trace\_type register.
\index{average (tes.base.TraceType attribute)@\spxentry{average}\spxextra{tes.base.TraceType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.TraceType.average}}\pysigline{\sphinxbfcode{\sphinxupquote{average}}\sphinxbfcode{\sphinxupquote{ = 1}}}
\end{fulllineitems}

\index{dot\_product (tes.base.TraceType attribute)@\spxentry{dot\_product}\spxextra{tes.base.TraceType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.TraceType.dot_product}}\pysigline{\sphinxbfcode{\sphinxupquote{dot\_product}}\sphinxbfcode{\sphinxupquote{ = 2}}}
\end{fulllineitems}

\index{dot\_product\_trace (tes.base.TraceType attribute)@\spxentry{dot\_product\_trace}\spxextra{tes.base.TraceType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.TraceType.dot_product_trace}}\pysigline{\sphinxbfcode{\sphinxupquote{dot\_product\_trace}}\sphinxbfcode{\sphinxupquote{ = 3}}}
\end{fulllineitems}

\index{single (tes.base.TraceType attribute)@\spxentry{single}\spxextra{tes.base.TraceType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.TraceType.single}}\pysigline{\sphinxbfcode{\sphinxupquote{single}}\sphinxbfcode{\sphinxupquote{ = 0}}}
\end{fulllineitems}


\end{fulllineitems}

\index{VhdlEnum (class in tes.base)@\spxentry{VhdlEnum}\spxextra{class in tes.base}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.VhdlEnum}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.base.}}\sphinxbfcode{\sphinxupquote{VhdlEnum}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{enum.Enum}}

\sphinxAtStartPar
An enumeration.
\index{latex() (tes.base.VhdlEnum method)@\spxentry{latex()}\spxextra{tes.base.VhdlEnum method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.VhdlEnum.latex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{latex}}}{}{}
\end{fulllineitems}

\index{select() (tes.base.VhdlEnum method)@\spxentry{select()}\spxextra{tes.base.VhdlEnum method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.VhdlEnum.select}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{select}}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{lookup() (in module tes.base)@\spxentry{lookup()}\spxextra{in module tes.base}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.lookup}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.base.}}\sphinxbfcode{\sphinxupquote{lookup}}}{\emph{\DUrole{n}{value}}, \emph{\DUrole{n}{enum}}}{}
\end{fulllineitems}

\index{pulse\_fmt() (in module tes.base)@\spxentry{pulse\_fmt()}\spxextra{in module tes.base}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.pulse_fmt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.base.}}\sphinxbfcode{\sphinxupquote{pulse\_fmt}}}{\emph{\DUrole{n}{n}}}{}
\end{fulllineitems}

\index{rise2\_fmt() (in module tes.base)@\spxentry{rise2\_fmt()}\spxextra{in module tes.base}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.base.rise2_fmt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.base.}}\sphinxbfcode{\sphinxupquote{rise2\_fmt}}}{\emph{\DUrole{n}{n}}}{}
\end{fulllineitems}



\subsubsection{tes.calibration module}
\label{\detokenize{tes:module-tes.calibration}}\label{\detokenize{tes:tes-calibration-module}}\index{module@\spxentry{module}!tes.calibration@\spxentry{tes.calibration}}\index{tes.calibration@\spxentry{tes.calibration}!module@\spxentry{module}}
\sphinxAtStartPar
Functions to calibrate the TES detector.

\sphinxAtStartPar
Author: Leonardo Assis Morais
\index{area\_histogram() (in module tes.calibration)@\spxentry{area\_histogram()}\spxextra{in module tes.calibration}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.calibration.area_histogram}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.calibration.}}\sphinxbfcode{\sphinxupquote{area\_histogram}}}{\emph{\DUrole{n}{max\_area}}, \emph{\DUrole{n}{bin\_number}}, \emph{\DUrole{n}{areas}}}{}
\sphinxAtStartPar
Create an area histogram.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_area}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} \begin{description}
\item[{Maximum area allowed (remove extremely large areas not due to}] \leavevmode
\sphinxAtStartPar
photon detections).

\end{description}


\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_number}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of histogram bins.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{areas}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Data with areas of TES pulses.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{bin\_centre} (\sphinxstyleemphasis{np.darray}) \textendash{} Array with the positions of the histograms bin centres.
Used for plotting the histogram with correct values
for areas in the x\sphinxhyphen{}axis.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{counts} (\sphinxstyleemphasis{np.ndarray}) \textendash{} Histogram counts.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{error} (\sphinxstyleemphasis{np.ndarray}) \textendash{} Standard deviation for counts
(poissonian distribution assumed: std. = sqrt(counts).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{bin\_width} (\sphinxstyleemphasis{float}) \textendash{} Bin width for plotting.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{find\_thresholds() (in module tes.calibration)@\spxentry{find\_thresholds()}\spxextra{in module tes.calibration}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.calibration.find_thresholds}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.calibration.}}\sphinxbfcode{\sphinxupquote{find\_thresholds}}}{\emph{\DUrole{n}{gauss\_fit}}, \emph{\DUrole{n}{maxima\_list}}, \emph{\DUrole{n}{bin\_centre}}, \emph{\DUrole{n}{counts}}, \emph{\DUrole{n}{const}}}{}
\sphinxAtStartPar
Find the counting thresholds given a gaussian fit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gauss\_fit}} (\sphinxstyleliteralemphasis{\sphinxupquote{lmfit fit}}) \textendash{} Result of a least square minimisation using lmfit.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{maxima\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Array with the positions of maxima points.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_centre}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Array with centre bin positions for histogram.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{counts}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} List with counts for histogram.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{const}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Value used for scipy.optimise.brentq.
See ‘Notes’ below for more information.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{dist} (\sphinxstyleemphasis{list}) \textendash{} List with the normalised distributions.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{new\_thresh\_list} \textendash{} List of counting thresholds.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Requires}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{——\textendash{}} \textendash{} scipy.optimize.brentq

\end{itemize}


\end{description}\end{quote}
\subsubsection*{Notes}

\sphinxAtStartPar
Sometimes this function breaks if brentq function cannot find
roots. If that is the case, slowly increase the value of the
variable ‘const’.

\end{fulllineitems}

\index{gaussian\_model() (in module tes.calibration)@\spxentry{gaussian\_model()}\spxextra{in module tes.calibration}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.calibration.gaussian_model}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.calibration.}}\sphinxbfcode{\sphinxupquote{gaussian\_model}}}{\emph{\DUrole{n}{fitting}}, \emph{\DUrole{n}{counts}}, \emph{\DUrole{n}{bin\_centre}}, \emph{\DUrole{n}{max\_idx}}}{}
\sphinxAtStartPar
Implement mixture model comprised of gaussians.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fitting}} (\sphinxstyleliteralemphasis{\sphinxupquote{class lmfit.minimizer.MinimizerResult}}) \textendash{} Result from fitting using lmfit.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{counts}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Histogram counts.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_centre}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.darray}}) \textendash{} Array with the positions of the histograms bin centres.
Used for plotting the histogram with correct values
for areas in the x\sphinxhyphen{}axis.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of gaussian distributions used in the model.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{model} \textendash{} Model of composed of sum of gaussians using the results
obtained from the fitting with lmfit.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{guess\_histogram() (in module tes.calibration)@\spxentry{guess\_histogram()}\spxextra{in module tes.calibration}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.calibration.guess_histogram}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.calibration.}}\sphinxbfcode{\sphinxupquote{guess\_histogram}}}{\emph{\DUrole{n}{areas}}, \emph{\DUrole{n}{bin\_number}}, \emph{\DUrole{n}{win\_length}}, \emph{\DUrole{n}{minimum}}, \emph{\DUrole{n}{max\_area}}}{}
\sphinxAtStartPar
Create first guess for histogram fitting.

\sphinxAtStartPar
Using a Hann function to create an approximate fit for the
data, estimates the position for the centre of the different
peaks in the area histogram.

\sphinxAtStartPar
WARNING:
The Hann window fitting must be checked to see if
it is reasonable using the function plot\_guess.
\begin{quote}

\sphinxAtStartPar
maxima
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_number}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of bins used in histogram.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{win\_length}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Length of the Hann window used in the fit.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{minimum}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Minimum value for the function maxima to consider
a given number of counts as a peak.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_area}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Areas \textgreater{} max\_area are considered invalid counts and
removed from the analysis. Used to remove event with
anomalous areas.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{counts} (\sphinxstyleemphasis{np.darray}) \textendash{} Array with counts for each histogram bin.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{smooth\_hist} (\sphinxstyleemphasis{np.darray}) \textendash{} Array with the continuous fit used to determine
the positions of the maxima in the data.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{bin\_centre} (\sphinxstyleemphasis{np.darray}) \textendash{} Array with the positions of the histograms bin centres.
Used for plotting the histogram with correct values
for areas in the x\sphinxhyphen{}axis.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{max\_i} (\sphinxstyleemphasis{list}) \textendash{} List with the position of the maxima points.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{maxima() (in module tes.calibration)@\spxentry{maxima()}\spxextra{in module tes.calibration}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.calibration.maxima}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.calibration.}}\sphinxbfcode{\sphinxupquote{maxima}}}{\emph{\DUrole{n}{function}}, \emph{\DUrole{n}{thresh}\DUrole{o}{=}\DUrole{default_value}{10}}}{}
\sphinxAtStartPar
Find local maxima of a function f.

\sphinxAtStartPar
Uses rising zero crossings of the gradient of f to find function
local maxima.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{function}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} Function f to be analysed.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{thresh}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Only return a maxima if f{[}maxima{]} \textgreater{} thresh.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{array}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Array with maxima points of f.}

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_area() (in module tes.calibration)@\spxentry{plot\_area()}\spxextra{in module tes.calibration}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.calibration.plot_area}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.calibration.}}\sphinxbfcode{\sphinxupquote{plot\_area}}}{\emph{\DUrole{n}{ax}}, \emph{\DUrole{n}{bin\_centre}}, \emph{\DUrole{n}{counts}}, \emph{\DUrole{n}{error}}, \emph{\DUrole{n}{model}}, \emph{\DUrole{n}{plot\_steps}}}{}
\sphinxAtStartPar
Require area\_histogram to be run before.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{figure axis}}) \textendash{} Figure axis of the figure to be plotted.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_centre}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.darray}}) \textendash{} Array with the positions of the histograms bin centres.
Used for plotting the histogram with correct values
for areas in the x\sphinxhyphen{}axis.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{counts}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Histogram counts.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{error}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Standard deviation for counts

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{model}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Model generated with gaussian\_model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plot\_steps}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of histogram points to be skipped when plotting.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{None.}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Requires}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{——\textendash{}}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{area\_histogram}

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_guess() (in module tes.calibration)@\spxentry{plot\_guess()}\spxextra{in module tes.calibration}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.calibration.plot_guess}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.calibration.}}\sphinxbfcode{\sphinxupquote{plot\_guess}}}{\emph{\DUrole{n}{ax}}, \emph{\DUrole{n}{hist}}, \emph{\DUrole{n}{smooth\_hist}}, \emph{\DUrole{n}{bin\_centres}}, \emph{\DUrole{n}{max\_i}}}{}
\sphinxAtStartPar
Plot the histogram with an educated guess for its fitting.

\sphinxAtStartPar
Visual check if the maxima positions determined by the
guess\_thresholds are reasonable.

\sphinxAtStartPar
Requires guess\_thresholds.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{figure axis}}) \textendash{} Figure axis of the figure to be plotted.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hist}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.darray}}) \textendash{} Histogram obtained from the guess\_thresholds function.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{smooth\_hist}} \textendash{} Smoothed histogram obtained from the guess\_thresholds
function.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_centres}} \textendash{} Centre of the bins for the histogram. Obtained from the
guess\_thresholds function.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_i}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} List with the position of the maxima points for the
peaks in histogram. Obtained from the guess\_thresholds
function.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{ax} \textendash{} Axis for the figure with the histogram, smoothed histogram
and maxima points plotted.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
figure axis

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_histogram() (in module tes.calibration)@\spxentry{plot\_histogram()}\spxextra{in module tes.calibration}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.calibration.plot_histogram}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.calibration.}}\sphinxbfcode{\sphinxupquote{plot\_histogram}}}{\emph{\DUrole{n}{ax}}, \emph{\DUrole{n}{data}}, \emph{\DUrole{n}{bin\_number}}, \emph{\DUrole{n}{measurement}}}{}
\sphinxAtStartPar
Plot histogram of TES characteristics.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{figure axis}}) \textendash{} Figure axis of the figure to be plotted.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Data extracted from TES (height, area, length, maximum slope).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_number}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of histogram bins.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{measurement}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Type of measurement plotted.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\item[{Return type}] \leavevmode
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_normalised() (in module tes.calibration)@\spxentry{plot\_normalised()}\spxextra{in module tes.calibration}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.calibration.plot_normalised}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.calibration.}}\sphinxbfcode{\sphinxupquote{plot\_normalised}}}{\emph{\DUrole{n}{ax}}, \emph{\DUrole{n}{max\_i}}, \emph{\DUrole{n}{bin\_centre}}, \emph{\DUrole{n}{dist}}, \emph{\DUrole{n}{thresholds}}}{}
\sphinxAtStartPar
Plot the graph with the normalised distributions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{figure axis}}) \textendash{} Figure axis of the figure to be plotted.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_i}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Number of distributions to be plotted.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_centre}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} x\sphinxhyphen{}axis positions for histogram data.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dist}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Distributions to be plotted.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{thresholds}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Counting thresholds positions to be plotted.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\item[{Return type}] \leavevmode
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{residual\_gauss() (in module tes.calibration)@\spxentry{residual\_gauss()}\spxextra{in module tes.calibration}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.calibration.residual_gauss}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.calibration.}}\sphinxbfcode{\sphinxupquote{residual\_gauss}}}{\emph{\DUrole{n}{params}}, \emph{\DUrole{n}{i\_var}}, \emph{\DUrole{n}{data}}, \emph{\DUrole{n}{eps\_data}}, \emph{\DUrole{n}{max\_idx}}}{}
\sphinxAtStartPar
Gaussian model to fit histogram from TES detections.

\sphinxAtStartPar
Model composed of a sum of N gaussian distributions, to be used
with the lmfit package to fit histograms from TES detections.
Returns the residual between data and model, divided by the
error in the data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{lmfit object}}) \textendash{} List of parameters to be used in the fit.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{i\_var}} \textendash{} Independent variable to be used in the fit.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Data to be fitted.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{eps\_data}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Standard deviation of each data point.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of gaussian distributions used in the model.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{residual} \textendash{} Array with the different between data and model
divided by the error in data.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{tes.counts module}
\label{\detokenize{tes:module-tes.counts}}\label{\detokenize{tes:tes-counts-module}}\index{module@\spxentry{module}!tes.counts@\spxentry{tes.counts}}\index{tes.counts@\spxentry{tes.counts}!module@\spxentry{module}}
\sphinxAtStartPar
Module to assist in counting photons routine.

\sphinxAtStartPar
1) coincidence
3) window
\index{Counts (class in tes.counts)@\spxentry{Counts}\spxextra{class in tes.counts}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.counts.Counts}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.counts.}}\sphinxbfcode{\sphinxupquote{Counts}}}{\emph{\DUrole{n}{count}}, \emph{\DUrole{n}{uncorrelated}}, \emph{\DUrole{n}{vacuum}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{tuple}}
\index{count (tes.counts.Counts property)@\spxentry{count}\spxextra{tes.counts.Counts property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.counts.Counts.count}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{count}}}
\sphinxAtStartPar
Alias for field number 0

\end{fulllineitems}

\index{uncorrelated (tes.counts.Counts property)@\spxentry{uncorrelated}\spxextra{tes.counts.Counts property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.counts.Counts.uncorrelated}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{uncorrelated}}}
\sphinxAtStartPar
Alias for field number 1

\end{fulllineitems}

\index{vacuum (tes.counts.Counts property)@\spxentry{vacuum}\spxextra{tes.counts.Counts property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.counts.Counts.vacuum}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{vacuum}}}
\sphinxAtStartPar
Alias for field number 2

\end{fulllineitems}


\end{fulllineitems}

\index{coincidence() (in module tes.counts)@\spxentry{coincidence()}\spxextra{in module tes.counts}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.counts.coincidence}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.counts.}}\sphinxbfcode{\sphinxupquote{coincidence}}}{\emph{\DUrole{n}{abs\_time}}, \emph{\DUrole{n}{mask}}, \emph{\DUrole{n}{low}}, \emph{\DUrole{n}{high}}}{}
\sphinxAtStartPar
Find coincidences between two channels.

\sphinxAtStartPar
After finding a coincidence, return indices of coincident events.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{abs\_time}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} Array where each entry corresponds to the time which the
detection was performed with respect to an initial time t0.
This array can be constructed using
np.cumsum(CaptureData(datapath).times).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray bool}}) \textendash{} Identifies the channels in abs\_time.
For abs\_times where mask is False, time t is coincident if
abs\_time+low \textless{}= t \textless{}= abs\_time+high.
If the mask is True t is coincident if
abs\_time\sphinxhyphen{}high \textless{}= t \textless{}= abs\_time\sphinxhyphen{}low.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{low}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The starting of the coincidence window.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{high}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The ending side of the coincidence window.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{coincidences(coinc, coinc\_mask)} (\sphinxstyleemphasis{tuple}) \textendash{}
\begin{description}
\item[{coinc}] \leavevmode{[}ndarray{]}
\sphinxAtStartPar
Indexes of the coincident event in the other channel.
When more than one event is found in the window the negated
value of the first index is entered.

\item[{coinc\_mask}] \leavevmode{[}ndarray bool{]}
\sphinxAtStartPar
Indicates where exactly one event was found in the window.

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Requires}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{———} \textendash{} tes.counts.window

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{counting\_photons() (in module tes.counts)@\spxentry{counting\_photons()}\spxextra{in module tes.counts}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.counts.counting_photons}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.counts.}}\sphinxbfcode{\sphinxupquote{counting\_photons}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{thresh\_list}}, \emph{\DUrole{n}{vacuum}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{coinc\_mask}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{herald\_mask}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Convert TES pulse area in photon\sphinxhyphen{}number.

\sphinxAtStartPar
Given an TES pulse area data set and the calibration (list with the
counting thresholds, passed through thresh\_list), returns
the number of counts for each Fock state.

\sphinxAtStartPar
If the mask with the heralding source is given, also includes
the number of vacuum counts.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Measured data.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{thresh\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} List with the counting thresholds obtained after detector
calibration.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{vacuum}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If true, it will use the herald\_mask to calculate vacuum
counts

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coinc\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Mask indicating coincidence counts.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{herald\_mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Mask indicating which events are in the heralding channel.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar

\sphinxAtStartPar
\sphinxstylestrong{Counts(count, uncorrelated, vacuum)} \textendash{}
\begin{description}
\item[{count}] \leavevmode{[}ndarray{]}
\sphinxAtStartPar
Counts for each photon number

\item[{uncorrelated :}] \leavevmode
\sphinxAtStartPar
Counts events not correlated with herald.
Only calculated when coinc\_mask and herald\_mask are
provided.

\item[{vacuum :}] \leavevmode
\sphinxAtStartPar
indicates if count{[}0{]} contains vacuum counts

\end{description}


\item[{Return type}] \leavevmode
\sphinxAtStartPar
named tuple

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_thresholds() (in module tes.counts)@\spxentry{get\_thresholds()}\spxextra{in module tes.counts}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.counts.get_thresholds}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.counts.}}\sphinxbfcode{\sphinxupquote{get\_thresholds}}}{\emph{\DUrole{n}{calibration\_file}}}{}
\sphinxAtStartPar
Load the threshold from a calibration file.

\sphinxAtStartPar
Calibration file must be generated with “TES\_Calibration.ipynb”.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{calibration\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Calibration file path.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{thresholds} \textendash{} Array with the threshold positions.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{window() (in module tes.counts)@\spxentry{window()}\spxextra{in module tes.counts}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.counts.window}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.counts.}}\sphinxbfcode{\sphinxupquote{window}}}{\emph{\DUrole{n}{ind}}, \emph{\DUrole{n}{abs\_time}}, \emph{\DUrole{n}{low}}, \emph{\DUrole{n}{high}}}{}
\sphinxAtStartPar
Find coincident events in the given window.

\sphinxAtStartPar
Get offsets from the current index ind in abs\_time that are in the
relative time window defined by low and high.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ind}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Current index for abs\_time.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{abs\_time}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} Absolute times.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{low}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Starting point of the relative window.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{high}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Ending point of the relative window.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{(low\_index, high\_index)} \textendash{} coincident times are abs\_time{[}low\_index:ind+high\_index{]}

\item[{Return type}] \leavevmode
\sphinxAtStartPar
tuple

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{tes.data module}
\label{\detokenize{tes:module-tes.data}}\label{\detokenize{tes:tes-data-module}}\index{module@\spxentry{module}!tes.data@\spxentry{tes.data}}\index{tes.data@\spxentry{tes.data}!module@\spxentry{module}}
\sphinxAtStartPar
Functions:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
FpgaStats

\item {} 
\sphinxAtStartPar
capture

\item {} 
\sphinxAtStartPar
read\_mca

\item {} 
\sphinxAtStartPar
av\_trace

\item {} 
\sphinxAtStartPar
\_memmap\_data

\end{enumerate}

\sphinxAtStartPar
Classes:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
FpgaStats

\item {} 
\sphinxAtStartPar
CaptureResult

\item {} 
\sphinxAtStartPar
CaptureData

\end{enumerate}
\index{CaptureData (class in tes.data)@\spxentry{CaptureData}\spxextra{class in tes.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.data.CaptureData}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.data.}}\sphinxbfcode{\sphinxupquote{CaptureData}}}{\emph{\DUrole{n}{path}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}
\index{homogeneous (tes.data.CaptureData property)@\spxentry{homogeneous}\spxextra{tes.data.CaptureData property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.data.CaptureData.homogeneous}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{homogeneous}}}
\end{fulllineitems}

\index{mask() (tes.data.CaptureData method)@\spxentry{mask()}\spxextra{tes.data.CaptureData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.data.CaptureData.mask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mask}}}{\emph{\DUrole{n}{channel}}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{CaptureResult (class in tes.data)@\spxentry{CaptureResult}\spxextra{class in tes.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.data.CaptureResult}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.data.}}\sphinxbfcode{\sphinxupquote{CaptureResult}}}{\emph{\DUrole{n}{ticks}}, \emph{\DUrole{n}{events}}, \emph{\DUrole{n}{traces}}, \emph{\DUrole{n}{mca}}, \emph{\DUrole{n}{frames}}, \emph{\DUrole{n}{dropped}}, \emph{\DUrole{n}{invalid}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{tes:tes.data.CaptureResult}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tes.data.CaptureResult}}}}}

\end{fulllineitems}

\index{FpgaStats (class in tes.data)@\spxentry{FpgaStats}\spxextra{class in tes.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.data.FpgaStats}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.data.}}\sphinxbfcode{\sphinxupquote{FpgaStats}}}{\emph{\DUrole{n}{frames}}, \emph{\DUrole{n}{dropped}}, \emph{\DUrole{n}{bad}}, \emph{\DUrole{n}{tick}}, \emph{\DUrole{n}{mca}}, \emph{\DUrole{n}{trace}}, \emph{\DUrole{n}{event}}, \emph{\DUrole{n}{types}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{tes.data.FpgaOutputStats}}

\sphinxAtStartPar
Class holding FPGA ethernet output statistics

\end{fulllineitems}

\index{av\_trace() (in module tes.data)@\spxentry{av\_trace()}\spxextra{in module tes.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.data.av_trace}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.data.}}\sphinxbfcode{\sphinxupquote{av\_trace}}}{\emph{\DUrole{n}{timeout}\DUrole{o}{=}\DUrole{default_value}{30}}}{}
\sphinxAtStartPar
Capture an average trace.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{timeout}} \textendash{} Timeout value in seconds.

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{capture() (in module tes.data)@\spxentry{capture()}\spxextra{in module tes.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.data.capture}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.data.}}\sphinxbfcode{\sphinxupquote{capture}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{n}{measurement}}, \emph{\DUrole{n}{use\_existing}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{access\_mode}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{ticks}\DUrole{o}{=}\DUrole{default_value}{10}}, \emph{\DUrole{n}{events}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{conversion\_mode}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\sphinxAtStartPar
Capture FPGA output as a collection of data and index files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filename}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{measurement}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ticks}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{events}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{write\_mode}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{conversion\_mode}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{capture\_mode}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\end{description}\end{quote}

\end{fulllineitems}

\index{fpga\_stats() (in module tes.data)@\spxentry{fpga\_stats()}\spxextra{in module tes.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.data.fpga_stats}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.data.}}\sphinxbfcode{\sphinxupquote{fpga\_stats}}}{\emph{\DUrole{n}{time}\DUrole{o}{=}\DUrole{default_value}{1.0}}}{}
\sphinxAtStartPar
Diagnostic statistics for the FPGA ethernet output.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time to capture statistics for

\item[{Returns}] \leavevmode
\sphinxAtStartPar
FpgaStats object that subclasses namedtuple.

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_mca() (in module tes.data)@\spxentry{read\_mca()}\spxextra{in module tes.data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.data.read_mca}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.data.}}\sphinxbfcode{\sphinxupquote{read\_mca}}}{\emph{\DUrole{n}{n}}}{}
\sphinxAtStartPar
Capture MCA histograms
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of histograms to capture

\item[{Returns}] \leavevmode
\sphinxAtStartPar
List of tes.mca.Distributions.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{tes.data\_acquisition module}
\label{\detokenize{tes:module-tes.data_acquisition}}\label{\detokenize{tes:tes-data-acquisition-module}}\index{module@\spxentry{module}!tes.data\_acquisition@\spxentry{tes.data\_acquisition}}\index{tes.data\_acquisition@\spxentry{tes.data\_acquisition}!module@\spxentry{module}}
\sphinxAtStartPar
Module used to perform measurements with the TES.

\sphinxAtStartPar
Functions:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
trace\_drive

\item {} 
\sphinxAtStartPar
pulse\_drive

\end{enumerate}
\index{pulse\_drive() (in module tes.data\_acquisition)@\spxentry{pulse\_drive()}\spxextra{in module tes.data\_acquisition}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.data_acquisition.pulse_drive}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.data\_acquisition.}}\sphinxbfcode{\sphinxupquote{pulse\_drive}}}{\emph{\DUrole{n}{time}}, \emph{\DUrole{n}{channel}}, \emph{\DUrole{n}{p\_thres}}, \emph{\DUrole{n}{s\_thres}}, \emph{\DUrole{n}{baseline\_sub}}, \emph{\DUrole{n}{datapath}}, \emph{\DUrole{n}{filename}}}{}
\sphinxAtStartPar
Perform measurements over TES traces.
\begin{description}
\item[{Measure the following characteristics of TES traces:}] \leavevmode\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
Length

\item {} 
\sphinxAtStartPar
Area

\item {} 
\sphinxAtStartPar
Maximum slope or height

\item {} 
\sphinxAtStartPar
Rise Time

\end{enumerate}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Time in seconds to take measurements.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{channel}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Processing channel chosen to take measurements.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p\_thres}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Pulse threshold chosen using the MCA.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s\_thres}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Slope threshold chosen using the MCA.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{base\_sub}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, the baseline correction will be activated.
It can automatically update the baseline level in
the case where it changes.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{datapath}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Folder where the registers will be saved.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the file where the registers will be saved.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\item[{Return type}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{trace\_drive() (in module tes.data\_acquisition)@\spxentry{trace\_drive()}\spxextra{in module tes.data\_acquisition}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.data_acquisition.trace_drive}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.data\_acquisition.}}\sphinxbfcode{\sphinxupquote{trace\_drive}}}{\emph{\DUrole{n}{time}}, \emph{\DUrole{n}{channel}}, \emph{\DUrole{n}{p\_thres}}, \emph{\DUrole{n}{s\_thres}}, \emph{\DUrole{n}{baseline\_sub}}, \emph{\DUrole{n}{datapath}}, \emph{\DUrole{n}{filename}}}{}
\sphinxAtStartPar
Record TES traces.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Time in seconds to take measurements.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{channel}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Processing channel chosen to take measurements.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{p\_thres}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Pulse threshold chosen using the MCA.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s\_thres}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Slope threshold chosen using the MCA.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{base\_sub}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, the baseline correction will be activated.
It can automatically update the baseline level in
the case where it changes.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{datapath}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Folder where the registers will be saved.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the file where the registers will be saved.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\item[{Return type}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}
\subsubsection*{Notes}

\sphinxAtStartPar
Keep your trace measurements up to 1 minute.

\end{fulllineitems}



\subsubsection{tes.folder\_management module}
\label{\detokenize{tes:module-tes.folder_management}}\label{\detokenize{tes:tes-folder-management-module}}\index{module@\spxentry{module}!tes.folder\_management@\spxentry{tes.folder\_management}}\index{tes.folder\_management@\spxentry{tes.folder\_management}!module@\spxentry{module}}
\sphinxAtStartPar
Module with convenient functions for folder management.

\sphinxAtStartPar
Contains:
\sphinxhyphen{} find\_folders
\sphinxhyphen{} manage\_folders
\index{find\_folders() (in module tes.folder\_management)@\spxentry{find\_folders()}\spxextra{in module tes.folder\_management}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.folder_management.find_folders}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.folder\_management.}}\sphinxbfcode{\sphinxupquote{find\_folders}}}{\emph{\DUrole{n}{master\_folder}}}{}
\sphinxAtStartPar
Search for folders inside the given address.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{master\_folder}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} address of the master folder on local computer.

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{AttributeError:}} \textendash{} Raises error when no folder can be found.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{measurements} \textendash{} list with the address of folders inside master\_folder.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
list

\end{description}\end{quote}

\end{fulllineitems}

\index{manage\_folders() (in module tes.folder\_management)@\spxentry{manage\_folders()}\spxextra{in module tes.folder\_management}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.folder_management.manage_folders}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.folder\_management.}}\sphinxbfcode{\sphinxupquote{manage\_folders}}}{\emph{\DUrole{n}{index}}, \emph{\DUrole{n}{measurement\_folders}}}{}
\sphinxAtStartPar
Create a folder structure for a given measurement set.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} (\sphinxstyleliteralemphasis{\sphinxupquote{integer}}) \textendash{} Select the measurement folder to be analysed

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{measurements}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} contains all addresses of measurement folders

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{AttributeError:}} \textendash{} Raises error when no folder can be found.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{description}
\item[{datapath}] \leavevmode{[}path{]}
\sphinxAtStartPar
address of the measurement folder

\item[{folder\_analysis}] \leavevmode{[}path{]}
\sphinxAtStartPar
address of the analysis folder

\item[{folder\_figures}] \leavevmode{[}path{]}
\sphinxAtStartPar
address of the figures folder

\end{description}


\item[{Return type}] \leavevmode
\sphinxAtStartPar
tuple with

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{tes.maps module}
\label{\detokenize{tes:module-tes.maps}}\label{\detokenize{tes:tes-maps-module}}\index{module@\spxentry{module}!tes.maps@\spxentry{tes.maps}}\index{tes.maps@\spxentry{tes.maps}!module@\spxentry{module}}
\sphinxAtStartPar
Classes:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
RegisterError

\item {} 
\sphinxAtStartPar
Borg

\item {} 
\sphinxAtStartPar
Transport\_base

\item {} 
\sphinxAtStartPar
\_ZmqTransport

\item {} 
\sphinxAtStartPar
\_DirectSerial

\item {} 
\sphinxAtStartPar
RegInfo

\end{enumerate}

\sphinxAtStartPar
Functions:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
\_map\_str

\item {} 
\sphinxAtStartPar
def \_field\_str

\item {} 
\sphinxAtStartPar
\_cpu\_version

\item {} 
\sphinxAtStartPar
\_from\_onehot

\item {} 
\sphinxAtStartPar
\_to\_onehot

\item {} 
\sphinxAtStartPar
\_to\_cf

\item {} 
\sphinxAtStartPar
\_from\_cf

\item {} 
\sphinxAtStartPar
\_to\_gain(g):

\item {} 
\sphinxAtStartPar
\_from\_gain

\end{enumerate}
\index{RegInfo (class in tes.maps)@\spxentry{RegInfo}\spxextra{class in tes.maps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.maps.RegInfo}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.maps.}}\sphinxbfcode{\sphinxupquote{RegInfo}}}{\emph{\DUrole{n}{address}}, \emph{\DUrole{n}{field}}, \emph{\DUrole{n}{strobe}}, \emph{\DUrole{n}{output\_transform}}, \emph{\DUrole{n}{input\_transform}}, \emph{\DUrole{n}{loadable}}, \emph{\DUrole{n}{name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{doc}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Class describing A FPGA register””
\index{get() (tes.maps.RegInfo method)@\spxentry{get()}\spxextra{tes.maps.RegInfo method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.maps.RegInfo.get}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get}}}{\emph{\DUrole{n}{transform}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{indices}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\end{fulllineitems}

\index{set() (tes.maps.RegInfo method)@\spxentry{set()}\spxextra{tes.maps.RegInfo method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.maps.RegInfo.set}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set}}}{\emph{\DUrole{n}{values}}, \emph{\DUrole{n}{transform}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{indices}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{RegisterError@\spxentry{RegisterError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.maps.RegisterError}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{tes.maps.}}\sphinxbfcode{\sphinxupquote{RegisterError}}}{\emph{\DUrole{n}{non\_hex}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{bad\_length}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{axi}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}OKAY\textquotesingle{}}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{AttributeError}}

\end{fulllineitems}



\subsubsection{tes.mca module}
\label{\detokenize{tes:module-tes.mca}}\label{\detokenize{tes:tes-mca-module}}\index{module@\spxentry{module}!tes.mca@\spxentry{tes.mca}}\index{tes.mca@\spxentry{tes.mca}!module@\spxentry{module}}
\sphinxAtStartPar
MCA low level control.

\sphinxAtStartPar
Classes:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
Value

\item {} 
\sphinxAtStartPar
Trigger

\item {} 
\sphinxAtStartPar
Qualifier

\item {} 
\sphinxAtStartPar
Distribution

\end{enumerate}
\index{Distribution (class in tes.mca)@\spxentry{Distribution}\spxextra{class in tes.mca}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Distribution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.mca.}}\sphinxbfcode{\sphinxupquote{Distribution}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{buffer}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
wrapper for transmitted zmq frame representing a MCA distribution
\index{bin\_width (tes.mca.Distribution property)@\spxentry{bin\_width}\spxextra{tes.mca.Distribution property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Distribution.bin_width}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{bin\_width}}}
\end{fulllineitems}

\index{bins (tes.mca.Distribution property)@\spxentry{bins}\spxextra{tes.mca.Distribution property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Distribution.bins}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{bins}}}
\end{fulllineitems}

\index{channel (tes.mca.Distribution property)@\spxentry{channel}\spxextra{tes.mca.Distribution property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Distribution.channel}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{channel}}}
\end{fulllineitems}

\index{highest\_value (tes.mca.Distribution property)@\spxentry{highest\_value}\spxextra{tes.mca.Distribution property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Distribution.highest_value}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{highest\_value}}}
\end{fulllineitems}

\index{last\_bin (tes.mca.Distribution property)@\spxentry{last\_bin}\spxextra{tes.mca.Distribution property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Distribution.last_bin}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{last\_bin}}}
\end{fulllineitems}

\index{lowest\_value (tes.mca.Distribution property)@\spxentry{lowest\_value}\spxextra{tes.mca.Distribution property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Distribution.lowest_value}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{lowest\_value}}}
\end{fulllineitems}

\index{most\_frequent (tes.mca.Distribution property)@\spxentry{most\_frequent}\spxextra{tes.mca.Distribution property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Distribution.most_frequent}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{most\_frequent}}}
\end{fulllineitems}

\index{overflow (tes.mca.Distribution property)@\spxentry{overflow}\spxextra{tes.mca.Distribution property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Distribution.overflow}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{overflow}}}
\end{fulllineitems}

\index{qualifier (tes.mca.Distribution property)@\spxentry{qualifier}\spxextra{tes.mca.Distribution property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Distribution.qualifier}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{qualifier}}}
\end{fulllineitems}

\index{start\_time (tes.mca.Distribution property)@\spxentry{start\_time}\spxextra{tes.mca.Distribution property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Distribution.start_time}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{start\_time}}}
\end{fulllineitems}

\index{stop\_time (tes.mca.Distribution property)@\spxentry{stop\_time}\spxextra{tes.mca.Distribution property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Distribution.stop_time}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{stop\_time}}}
\end{fulllineitems}

\index{total (tes.mca.Distribution property)@\spxentry{total}\spxextra{tes.mca.Distribution property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Distribution.total}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{total}}}
\end{fulllineitems}

\index{trigger (tes.mca.Distribution property)@\spxentry{trigger}\spxextra{tes.mca.Distribution property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Distribution.trigger}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{trigger}}}
\end{fulllineitems}

\index{underflow (tes.mca.Distribution property)@\spxentry{underflow}\spxextra{tes.mca.Distribution property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Distribution.underflow}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{underflow}}}
\end{fulllineitems}

\index{value (tes.mca.Distribution property)@\spxentry{value}\spxextra{tes.mca.Distribution property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Distribution.value}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{value}}}
\end{fulllineitems}


\end{fulllineitems}

\index{Qualifier (class in tes.mca)@\spxentry{Qualifier}\spxextra{class in tes.mca}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Qualifier}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.mca.}}\sphinxbfcode{\sphinxupquote{Qualifier}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{tes:tes.base.VhdlEnum}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tes.base.VhdlEnum}}}}}

\sphinxAtStartPar
An enumeration.
\index{above (tes.mca.Qualifier attribute)@\spxentry{above}\spxextra{tes.mca.Qualifier attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Qualifier.above}}\pysigline{\sphinxbfcode{\sphinxupquote{above}}\sphinxbfcode{\sphinxupquote{ = 4}}}
\end{fulllineitems}

\index{above\_area (tes.mca.Qualifier attribute)@\spxentry{above\_area}\spxextra{tes.mca.Qualifier attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Qualifier.above_area}}\pysigline{\sphinxbfcode{\sphinxupquote{above\_area}}\sphinxbfcode{\sphinxupquote{ = 3}}}
\end{fulllineitems}

\index{all (tes.mca.Qualifier attribute)@\spxentry{all}\spxextra{tes.mca.Qualifier attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Qualifier.all}}\pysigline{\sphinxbfcode{\sphinxupquote{all}}\sphinxbfcode{\sphinxupquote{ = 1}}}
\end{fulllineitems}

\index{armed (tes.mca.Qualifier attribute)@\spxentry{armed}\spxextra{tes.mca.Qualifier attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Qualifier.armed}}\pysigline{\sphinxbfcode{\sphinxupquote{armed}}\sphinxbfcode{\sphinxupquote{ = 6}}}
\end{fulllineitems}

\index{disabled (tes.mca.Qualifier attribute)@\spxentry{disabled}\spxextra{tes.mca.Qualifier attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Qualifier.disabled}}\pysigline{\sphinxbfcode{\sphinxupquote{disabled}}\sphinxbfcode{\sphinxupquote{ = 0}}}
\end{fulllineitems}

\index{rise (tes.mca.Qualifier attribute)@\spxentry{rise}\spxextra{tes.mca.Qualifier attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Qualifier.rise}}\pysigline{\sphinxbfcode{\sphinxupquote{rise}}\sphinxbfcode{\sphinxupquote{ = 8}}}
\end{fulllineitems}

\index{valid\_peak1 (tes.mca.Qualifier attribute)@\spxentry{valid\_peak1}\spxextra{tes.mca.Qualifier attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Qualifier.valid_peak1}}\pysigline{\sphinxbfcode{\sphinxupquote{valid\_peak1}}\sphinxbfcode{\sphinxupquote{ = 9}}}
\end{fulllineitems}

\index{valid\_peak2 (tes.mca.Qualifier attribute)@\spxentry{valid\_peak2}\spxextra{tes.mca.Qualifier attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Qualifier.valid_peak2}}\pysigline{\sphinxbfcode{\sphinxupquote{valid\_peak2}}\sphinxbfcode{\sphinxupquote{ = 10}}}
\end{fulllineitems}

\index{valid\_peak3 (tes.mca.Qualifier attribute)@\spxentry{valid\_peak3}\spxextra{tes.mca.Qualifier attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Qualifier.valid_peak3}}\pysigline{\sphinxbfcode{\sphinxupquote{valid\_peak3}}\sphinxbfcode{\sphinxupquote{ = 11}}}
\end{fulllineitems}

\index{valid\_rise (tes.mca.Qualifier attribute)@\spxentry{valid\_rise}\spxextra{tes.mca.Qualifier attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Qualifier.valid_rise}}\pysigline{\sphinxbfcode{\sphinxupquote{valid\_rise}}\sphinxbfcode{\sphinxupquote{ = 2}}}
\end{fulllineitems}

\index{will\_arm (tes.mca.Qualifier attribute)@\spxentry{will\_arm}\spxextra{tes.mca.Qualifier attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Qualifier.will_arm}}\pysigline{\sphinxbfcode{\sphinxupquote{will\_arm}}\sphinxbfcode{\sphinxupquote{ = 7}}}
\end{fulllineitems}

\index{will\_cross (tes.mca.Qualifier attribute)@\spxentry{will\_cross}\spxextra{tes.mca.Qualifier attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Qualifier.will_cross}}\pysigline{\sphinxbfcode{\sphinxupquote{will\_cross}}\sphinxbfcode{\sphinxupquote{ = 5}}}
\end{fulllineitems}


\end{fulllineitems}

\index{Trigger (class in tes.mca)@\spxentry{Trigger}\spxextra{class in tes.mca}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Trigger}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.mca.}}\sphinxbfcode{\sphinxupquote{Trigger}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{tes:tes.base.VhdlEnum}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tes.base.VhdlEnum}}}}}

\sphinxAtStartPar
An enumeration.
\index{cfd\_high (tes.mca.Trigger attribute)@\spxentry{cfd\_high}\spxextra{tes.mca.Trigger attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Trigger.cfd_high}}\pysigline{\sphinxbfcode{\sphinxupquote{cfd\_high}}\sphinxbfcode{\sphinxupquote{ = 9}}}
\end{fulllineitems}

\index{cfd\_low (tes.mca.Trigger attribute)@\spxentry{cfd\_low}\spxextra{tes.mca.Trigger attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Trigger.cfd_low}}\pysigline{\sphinxbfcode{\sphinxupquote{cfd\_low}}\sphinxbfcode{\sphinxupquote{ = 10}}}
\end{fulllineitems}

\index{clock (tes.mca.Trigger attribute)@\spxentry{clock}\spxextra{tes.mca.Trigger attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Trigger.clock}}\pysigline{\sphinxbfcode{\sphinxupquote{clock}}\sphinxbfcode{\sphinxupquote{ = 1}}}
\end{fulllineitems}

\index{disabled (tes.mca.Trigger attribute)@\spxentry{disabled}\spxextra{tes.mca.Trigger attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Trigger.disabled}}\pysigline{\sphinxbfcode{\sphinxupquote{disabled}}\sphinxbfcode{\sphinxupquote{ = 0}}}
\end{fulllineitems}

\index{f\_0xing (tes.mca.Trigger attribute)@\spxentry{f\_0xing}\spxextra{tes.mca.Trigger attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Trigger.f_0xing}}\pysigline{\sphinxbfcode{\sphinxupquote{f\_0xing}}\sphinxbfcode{\sphinxupquote{ = 5}}}
\end{fulllineitems}

\index{max\_slope (tes.mca.Trigger attribute)@\spxentry{max\_slope}\spxextra{tes.mca.Trigger attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Trigger.max_slope}}\pysigline{\sphinxbfcode{\sphinxupquote{max\_slope}}\sphinxbfcode{\sphinxupquote{ = 11}}}
\end{fulllineitems}

\index{pulse\_t\_neg (tes.mca.Trigger attribute)@\spxentry{pulse\_t\_neg}\spxextra{tes.mca.Trigger attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Trigger.pulse_t_neg}}\pysigline{\sphinxbfcode{\sphinxupquote{pulse\_t\_neg}}\sphinxbfcode{\sphinxupquote{ = 3}}}
\end{fulllineitems}

\index{pulse\_t\_pos (tes.mca.Trigger attribute)@\spxentry{pulse\_t\_pos}\spxextra{tes.mca.Trigger attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Trigger.pulse_t_pos}}\pysigline{\sphinxbfcode{\sphinxupquote{pulse\_t\_pos}}\sphinxbfcode{\sphinxupquote{ = 2}}}
\end{fulllineitems}

\index{s\_0xing (tes.mca.Trigger attribute)@\spxentry{s\_0xing}\spxextra{tes.mca.Trigger attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Trigger.s_0xing}}\pysigline{\sphinxbfcode{\sphinxupquote{s\_0xing}}\sphinxbfcode{\sphinxupquote{ = 6}}}
\end{fulllineitems}

\index{s\_0xing\_neg (tes.mca.Trigger attribute)@\spxentry{s\_0xing\_neg}\spxextra{tes.mca.Trigger attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Trigger.s_0xing_neg}}\pysigline{\sphinxbfcode{\sphinxupquote{s\_0xing\_neg}}\sphinxbfcode{\sphinxupquote{ = 8}}}
\end{fulllineitems}

\index{s\_0xing\_pos (tes.mca.Trigger attribute)@\spxentry{s\_0xing\_pos}\spxextra{tes.mca.Trigger attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Trigger.s_0xing_pos}}\pysigline{\sphinxbfcode{\sphinxupquote{s\_0xing\_pos}}\sphinxbfcode{\sphinxupquote{ = 7}}}
\end{fulllineitems}

\index{slope\_t\_pos (tes.mca.Trigger attribute)@\spxentry{slope\_t\_pos}\spxextra{tes.mca.Trigger attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Trigger.slope_t_pos}}\pysigline{\sphinxbfcode{\sphinxupquote{slope\_t\_pos}}\sphinxbfcode{\sphinxupquote{ = 4}}}
\end{fulllineitems}


\end{fulllineitems}

\index{Value (class in tes.mca)@\spxentry{Value}\spxextra{class in tes.mca}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Value}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.mca.}}\sphinxbfcode{\sphinxupquote{Value}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{tes:tes.base.VhdlEnum}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tes.base.VhdlEnum}}}}}

\sphinxAtStartPar
An enumeration.
\index{cfd\_high (tes.mca.Value attribute)@\spxentry{cfd\_high}\spxextra{tes.mca.Value attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Value.cfd_high}}\pysigline{\sphinxbfcode{\sphinxupquote{cfd\_high}}\sphinxbfcode{\sphinxupquote{ = 9}}}
\end{fulllineitems}

\index{disabled (tes.mca.Value attribute)@\spxentry{disabled}\spxextra{tes.mca.Value attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Value.disabled}}\pysigline{\sphinxbfcode{\sphinxupquote{disabled}}\sphinxbfcode{\sphinxupquote{ = 0}}}
\end{fulllineitems}

\index{f (tes.mca.Value attribute)@\spxentry{f}\spxextra{tes.mca.Value attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Value.f}}\pysigline{\sphinxbfcode{\sphinxupquote{f}}\sphinxbfcode{\sphinxupquote{ = 1}}}
\end{fulllineitems}

\index{f\_area (tes.mca.Value attribute)@\spxentry{f\_area}\spxextra{tes.mca.Value attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Value.f_area}}\pysigline{\sphinxbfcode{\sphinxupquote{f\_area}}\sphinxbfcode{\sphinxupquote{ = 2}}}
\end{fulllineitems}

\index{f\_extrema (tes.mca.Value attribute)@\spxentry{f\_extrema}\spxextra{tes.mca.Value attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Value.f_extrema}}\pysigline{\sphinxbfcode{\sphinxupquote{f\_extrema}}\sphinxbfcode{\sphinxupquote{ = 3}}}
\end{fulllineitems}

\index{pulse\_area (tes.mca.Value attribute)@\spxentry{pulse\_area}\spxextra{tes.mca.Value attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Value.pulse_area}}\pysigline{\sphinxbfcode{\sphinxupquote{pulse\_area}}\sphinxbfcode{\sphinxupquote{ = 7}}}
\end{fulllineitems}

\index{pulse\_timer (tes.mca.Value attribute)@\spxentry{pulse\_timer}\spxextra{tes.mca.Value attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Value.pulse_timer}}\pysigline{\sphinxbfcode{\sphinxupquote{pulse\_timer}}\sphinxbfcode{\sphinxupquote{ = 10}}}
\end{fulllineitems}

\index{raw (tes.mca.Value attribute)@\spxentry{raw}\spxextra{tes.mca.Value attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Value.raw}}\pysigline{\sphinxbfcode{\sphinxupquote{raw}}\sphinxbfcode{\sphinxupquote{ = 8}}}
\end{fulllineitems}

\index{rise\_timer (tes.mca.Value attribute)@\spxentry{rise\_timer}\spxextra{tes.mca.Value attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Value.rise_timer}}\pysigline{\sphinxbfcode{\sphinxupquote{rise\_timer}}\sphinxbfcode{\sphinxupquote{ = 11}}}
\end{fulllineitems}

\index{s (tes.mca.Value attribute)@\spxentry{s}\spxextra{tes.mca.Value attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Value.s}}\pysigline{\sphinxbfcode{\sphinxupquote{s}}\sphinxbfcode{\sphinxupquote{ = 4}}}
\end{fulllineitems}

\index{s\_area (tes.mca.Value attribute)@\spxentry{s\_area}\spxextra{tes.mca.Value attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Value.s_area}}\pysigline{\sphinxbfcode{\sphinxupquote{s\_area}}\sphinxbfcode{\sphinxupquote{ = 5}}}
\end{fulllineitems}

\index{s\_extrema (tes.mca.Value attribute)@\spxentry{s\_extrema}\spxextra{tes.mca.Value attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca.Value.s_extrema}}\pysigline{\sphinxbfcode{\sphinxupquote{s\_extrema}}\sphinxbfcode{\sphinxupquote{ = 6}}}
\end{fulllineitems}


\end{fulllineitems}



\subsubsection{tes.mca\_control module}
\label{\detokenize{tes:module-tes.mca_control}}\label{\detokenize{tes:tes-mca-control-module}}\index{module@\spxentry{module}!tes.mca\_control@\spxentry{tes.mca\_control}}\index{tes.mca\_control@\spxentry{tes.mca\_control}!module@\spxentry{module}}
\sphinxAtStartPar
Module with functions to control the MCA.

\sphinxAtStartPar
Should be used together with the Jupyter Notebook
“MCA\_and\_Measurements.ipynb”.

\sphinxAtStartPar
Functions defined here:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
configure\_channels

\item {} 
\sphinxAtStartPar
baseline\_offset

\item {} 
\sphinxAtStartPar
pulse\_threshold

\item {} 
\sphinxAtStartPar
slope\_threshold

\item {} 
\sphinxAtStartPar
area\_histogram

\end{enumerate}
\index{area\_histogram() (in module tes.mca\_control)@\spxentry{area\_histogram()}\spxextra{in module tes.mca\_control}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca_control.area_histogram}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.mca\_control.}}\sphinxbfcode{\sphinxupquote{area\_histogram}}}{\emph{\DUrole{n}{registers}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{channel}}, \emph{\DUrole{n}{bin\_width}}, \emph{\DUrole{n}{p\_thres}}, \emph{\DUrole{n}{s\_thres}}, \emph{\DUrole{n}{xrange}}, \emph{\DUrole{n}{yrange}}}{}
\sphinxAtStartPar
Plot area histogram given the thresholds chosen.

\sphinxAtStartPar
Always run this function to realise a sanity test for the selected
values for baseline offset, pulse threshold and slope
threshold.
You should be able to see clear distinct peaks indicating that
the current configuration of the TES can discriminate number of
photons.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{registers}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionary that stores the values of all registers that control
the measurements performed by the FPGA.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Time (in seconds) the histogram should be accumulated over.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{channel}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Channel to be analysed.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_width}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} 2\textasciicircum{}(bin\_width) will be the width of the histogram bin.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s\_thres}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Determine the pulse threshold.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{(fig,)} \textendash{} Figure with the plotted histogram.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
tuple

\end{description}\end{quote}

\end{fulllineitems}

\index{baseline\_offset() (in module tes.mca\_control)@\spxentry{baseline\_offset()}\spxextra{in module tes.mca\_control}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca_control.baseline_offset}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.mca\_control.}}\sphinxbfcode{\sphinxupquote{baseline\_offset}}}{\emph{\DUrole{n}{registers}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{channel}}, \emph{\DUrole{n}{bin\_width}}, \emph{\DUrole{n}{baseline\_offset}}}{}
\sphinxAtStartPar
Determine the detection baseline for TES detections.

\sphinxAtStartPar
Change the values of baseline\_offset until you see a big peak
in the  histogram. When the peak appears, put its centre at
x = 0 by choosing an  appropriate baseline\_offset.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{registers}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionary that stores the values of all registers that
control the measurements performed by the FPGA.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Time (in seconds) the histogram should be accumulated over.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{channel}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Channel to be analysed.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_width}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} 2\textasciicircum{}(bin\_width) will be the width of the histogram bin

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{baseline\_offset}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Determine the baseline offset.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{(fig,)} \textendash{} Figure with the plotted histogram.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
tuple

\end{description}\end{quote}

\end{fulllineitems}

\index{configure\_channels() (in module tes.mca\_control)@\spxentry{configure\_channels()}\spxextra{in module tes.mca\_control}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca_control.configure_channels}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.mca\_control.}}\sphinxbfcode{\sphinxupquote{configure\_channels}}}{\emph{\DUrole{n}{registers}}, \emph{\DUrole{n}{adc\_channel}}, \emph{\DUrole{n}{proc\_channel}}, \emph{\DUrole{n}{invert}}}{}
\sphinxAtStartPar
Configure connections to ADC channels.

\sphinxAtStartPar
Connects the selected ADC channel (check in the lab to which
ADC channel you connected the TES cables) to the selected
processing channel (digital channel to which you will refer
in the next steps of the notebook).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{registers}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionary that stores the values of all registers that control
the measurements performed by the FPGA.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{adc\_channel}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Determine which adc channel is being used.
May assume values 0\sphinxhyphen{}7.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{proc\_channel}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Determine which processing channel is being used.
May assume values 0\sphinxhyphen{}1.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{invert}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Determines if the signal polarisation should be inverted.
True inverts, False does not invert.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\item[{Return type}] \leavevmode
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{pulse\_threshold() (in module tes.mca\_control)@\spxentry{pulse\_threshold()}\spxextra{in module tes.mca\_control}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca_control.pulse_threshold}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.mca\_control.}}\sphinxbfcode{\sphinxupquote{pulse\_threshold}}}{\emph{\DUrole{n}{registers}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{channel}}, \emph{\DUrole{n}{bin\_width}}, \emph{\DUrole{n}{p\_thres}}}{}
\sphinxAtStartPar
Determine the pulse threshold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{registers}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionary that stores the values of all registers that control
the measurements performed by the FPGA.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Time (in seconds) the histogram should be accumulated over.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{channel}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Channel to be analysed.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_width}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} 2\textasciicircum{}(bin\_width) will be the width of the histogram bin.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pulse\_threshold}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Determine the pulse threshold.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{(fig,)} \textendash{} Figure with the plotted histogram.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
tuple

\end{description}\end{quote}

\end{fulllineitems}

\index{slope\_threshold() (in module tes.mca\_control)@\spxentry{slope\_threshold()}\spxextra{in module tes.mca\_control}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.mca_control.slope_threshold}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.mca\_control.}}\sphinxbfcode{\sphinxupquote{slope\_threshold}}}{\emph{\DUrole{n}{registers}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{channel}}, \emph{\DUrole{n}{bin\_width}}, \emph{\DUrole{n}{s\_thres}}}{}
\sphinxAtStartPar
Determine the slope threshold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{registers}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionary that stores the values of all registers that control
the measurements performed by the FPGA.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Time (in seconds) the histogram should be accumulated over.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{channel}} (\sphinxstyleliteralemphasis{\sphinxupquote{in}}) \textendash{} Channel to be analysed.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bin\_width}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} 2\textasciicircum{}(bin\_width) will be the width of the histogram bin.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s\_thres}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Determine the pulse threshold.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{(fig,)} \textendash{} Figure with the plotted histogram.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
tuple

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{tes.protocol module}
\label{\detokenize{tes:module-tes.protocol}}\label{\detokenize{tes:tes-protocol-module}}\index{module@\spxentry{module}!tes.protocol@\spxentry{tes.protocol}}\index{tes.protocol@\spxentry{tes.protocol}!module@\spxentry{module}}
\sphinxAtStartPar
Classes:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
PayloadType

\end{enumerate}
\index{PayloadType (class in tes.protocol)@\spxentry{PayloadType}\spxextra{class in tes.protocol}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.protocol.PayloadType}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.protocol.}}\sphinxbfcode{\sphinxupquote{PayloadType}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{enum.IntEnum}}

\sphinxAtStartPar
An enumeration.
\index{area (tes.protocol.PayloadType attribute)@\spxentry{area}\spxextra{tes.protocol.PayloadType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.protocol.PayloadType.area}}\pysigline{\sphinxbfcode{\sphinxupquote{area}}\sphinxbfcode{\sphinxupquote{ = 1}}}
\end{fulllineitems}

\index{mca (tes.protocol.PayloadType attribute)@\spxentry{mca}\spxextra{tes.protocol.PayloadType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.protocol.PayloadType.mca}}\pysigline{\sphinxbfcode{\sphinxupquote{mca}}\sphinxbfcode{\sphinxupquote{ = 5}}}
\end{fulllineitems}

\index{peak (tes.protocol.PayloadType attribute)@\spxentry{peak}\spxextra{tes.protocol.PayloadType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.protocol.PayloadType.peak}}\pysigline{\sphinxbfcode{\sphinxupquote{peak}}\sphinxbfcode{\sphinxupquote{ = 0}}}
\end{fulllineitems}

\index{pulse (tes.protocol.PayloadType attribute)@\spxentry{pulse}\spxextra{tes.protocol.PayloadType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.protocol.PayloadType.pulse}}\pysigline{\sphinxbfcode{\sphinxupquote{pulse}}\sphinxbfcode{\sphinxupquote{ = 2}}}
\end{fulllineitems}

\index{tick (tes.protocol.PayloadType attribute)@\spxentry{tick}\spxextra{tes.protocol.PayloadType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.protocol.PayloadType.tick}}\pysigline{\sphinxbfcode{\sphinxupquote{tick}}\sphinxbfcode{\sphinxupquote{ = 4}}}
\end{fulllineitems}

\index{trace (tes.protocol.PayloadType attribute)@\spxentry{trace}\spxextra{tes.protocol.PayloadType attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.protocol.PayloadType.trace}}\pysigline{\sphinxbfcode{\sphinxupquote{trace}}\sphinxbfcode{\sphinxupquote{ = 3}}}
\end{fulllineitems}


\end{fulllineitems}



\subsubsection{tes.registers module}
\label{\detokenize{tes:module-tes.registers}}\label{\detokenize{tes:tes-registers-module}}\index{module@\spxentry{module}!tes.registers@\spxentry{tes.registers}}\index{tes.registers@\spxentry{tes.registers}!module@\spxentry{module}}
\sphinxAtStartPar
Functions:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
\_adc\_spi\_transform

\item {} 
\sphinxAtStartPar
\_channel\_transform

\item {} 
\sphinxAtStartPar
save

\item {} 
\sphinxAtStartPar
load

\end{enumerate}

\sphinxAtStartPar
Classes:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
\_RegisterMap

\item {} 
\sphinxAtStartPar
\_RegisterGroup

\item {} 
\sphinxAtStartPar
\_GroupIterator

\item {} 
\sphinxAtStartPar
Registers

\end{enumerate}
\index{Registers (class in tes.registers)@\spxentry{Registers}\spxextra{class in tes.registers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.registers.Registers}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tes.registers.}}\sphinxbfcode{\sphinxupquote{Registers}}}{\emph{\DUrole{n}{port}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{tes.registers.\_RegisterMap}}

\sphinxAtStartPar
Client for reading and writing the internal FPGA control registers.

\sphinxAtStartPar
Registers are arranged in functional groups and accessed through an
instance of the Registers class. Let r be an instance of Registers
then r.regname  references the regname register while r.groupname.regname
the regname register of the  groupname group. Some groups support
indexing to reference a register for a particular channel. Slicing and
fancy indexing are supported while ommiting indexing is equvalent  to
referencing ALL channels.

\sphinxAtStartPar
For example:
r.groupname{[}0{]}.regname refers to the regname register of the groupname group
for channel 0. While r.groupname.regname refers to the same register for all
channels. Therefore, r.groupname.regname will return a list containing the
value of the register for each channel, r.groupname.regname = value will set
the for all channels to the same value and
r.groupname.regname = {[}value0, value1, …, valuen{]} will broadcast the list
of values to the appropriate channel.

\sphinxAtStartPar
Groups without indexing:
No groupnme \sphinxhyphen{} accesses a general register. See help(Registers).
mca \sphinxhyphen{} accesses the registers controlling the MCA. See help(McaRegisters).

\sphinxAtStartPar
Groups supporting indexing:
channel controls input to the processing channels. See help(ChannelRegisters
event  controls event output. See help(EventRegisters).
baseline  controls the baseline process. See help(BaselineRegisters).
cfd  controls the constant fraction process. See help(CfdRegisters).
adc  controls the ADC chips. See help(AdcRegisters).

\sphinxAtStartPar
The the number of channels in the adc group is twice the value of the
general register adc\_chips while the number of channels in all other
groups is the value of the general register channel\_count.

\sphinxAtStartPar
TODO add dict indexing
\index{adc (tes.registers.Registers attribute)@\spxentry{adc}\spxextra{tes.registers.Registers attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.registers.Registers.adc}}\pysigline{\sphinxbfcode{\sphinxupquote{adc}}}
\sphinxAtStartPar
Registers controlling the ADC chips on the FMC108 digitiser
card.

\end{fulllineitems}

\index{baseline (tes.registers.Registers attribute)@\spxentry{baseline}\spxextra{tes.registers.Registers attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.registers.Registers.baseline}}\pysigline{\sphinxbfcode{\sphinxupquote{baseline}}}
\sphinxAtStartPar
Registers controlling baseline correction.

\end{fulllineitems}

\index{cfd (tes.registers.Registers attribute)@\spxentry{cfd}\spxextra{tes.registers.Registers attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.registers.Registers.cfd}}\pysigline{\sphinxbfcode{\sphinxupquote{cfd}}}
\sphinxAtStartPar
Registers controlling the cfd process.

\end{fulllineitems}

\index{channel (tes.registers.Registers attribute)@\spxentry{channel}\spxextra{tes.registers.Registers attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.registers.Registers.channel}}\pysigline{\sphinxbfcode{\sphinxupquote{channel}}}
\sphinxAtStartPar
Registers controlling channel input.

\end{fulllineitems}

\index{event (tes.registers.Registers attribute)@\spxentry{event}\spxextra{tes.registers.Registers attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.registers.Registers.event}}\pysigline{\sphinxbfcode{\sphinxupquote{event}}}
\sphinxAtStartPar
Registers controlling event output.

\end{fulllineitems}

\index{mca (tes.registers.Registers attribute)@\spxentry{mca}\spxextra{tes.registers.Registers attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.registers.Registers.mca}}\pysigline{\sphinxbfcode{\sphinxupquote{mca}}}
\sphinxAtStartPar
Registers controlling the MCA

\end{fulllineitems}


\end{fulllineitems}

\index{load() (in module tes.registers)@\spxentry{load()}\spxextra{in module tes.registers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.registers.load}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.registers.}}\sphinxbfcode{\sphinxupquote{load}}}{\emph{\DUrole{n}{filename}}}{}
\end{fulllineitems}

\index{save() (in module tes.registers)@\spxentry{save()}\spxextra{in module tes.registers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.registers.save}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.registers.}}\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{d}}, \emph{\DUrole{n}{filename}}}{}
\end{fulllineitems}



\subsubsection{tes.traces module}
\label{\detokenize{tes:module-tes.traces}}\label{\detokenize{tes:tes-traces-module}}\index{module@\spxentry{module}!tes.traces@\spxentry{tes.traces}}\index{tes.traces@\spxentry{tes.traces}!module@\spxentry{module}}
\sphinxAtStartPar
Module to be used with jupyter notebook TES Trace Generator.

\sphinxAtStartPar
Contains:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
extract\_data

\item {} 
\sphinxAtStartPar
create\_statistics\_file

\item {} 
\sphinxAtStartPar
plot\_traces

\item {} 
\sphinxAtStartPar
correct\_xticks

\item {} 
\sphinxAtStartPar
correct\_yticks

\end{enumerate}
\index{correct\_xticks() (in module tes.traces)@\spxentry{correct\_xticks()}\spxextra{in module tes.traces}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.traces.correct_xticks}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.traces.}}\sphinxbfcode{\sphinxupquote{correct\_xticks}}}{\emph{\DUrole{n}{ax}}}{}
\sphinxAtStartPar
Properly edit the xticks for a matplotlib plot.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{axis object}}) \textendash{} Axis with x\sphinxhyphen{}axis to be edited.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ax} (\sphinxstyleemphasis{axis object}) \textendash{} Edited axis object.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{expx} (\sphinxstyleemphasis{int}) \textendash{} Integer to be added to the x\sphinxhyphen{}axis label.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{correct\_yticks() (in module tes.traces)@\spxentry{correct\_yticks()}\spxextra{in module tes.traces}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.traces.correct_yticks}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.traces.}}\sphinxbfcode{\sphinxupquote{correct\_yticks}}}{\emph{\DUrole{n}{ax}}}{}
\sphinxAtStartPar
Properly edit the yticks for a matplotlib plot.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{axis object}}) \textendash{} Axis with x\sphinxhyphen{}axis to be edited.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ax} (\sphinxstyleemphasis{axis object}) \textendash{} Edited axis object.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{expy} (\sphinxstyleemphasis{int}) \textendash{} Integer to be added to the x\sphinxhyphen{}axis label.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{create\_statistics\_file() (in module tes.traces)@\spxentry{create\_statistics\_file()}\spxextra{in module tes.traces}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.traces.create_statistics_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.traces.}}\sphinxbfcode{\sphinxupquote{create\_statistics\_file}}}{\emph{\DUrole{n}{measurement\_folders}}}{}
\sphinxAtStartPar
Create file with measurements statistics in measurement folder.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{measurement\_folder}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of paths}}) \textendash{} list containing the paths of the folders where the measurements
are stored and where the stats files will be created.

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\item[{Return type}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{extract\_data() (in module tes.traces)@\spxentry{extract\_data()}\spxextra{in module tes.traces}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.traces.extract_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.traces.}}\sphinxbfcode{\sphinxupquote{extract\_data}}}{\emph{\DUrole{n}{datapath}}, \emph{\DUrole{n}{measurements}}}{}
\sphinxAtStartPar
Extract data and registers for a given address.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{datapath}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} String containing the measurement folder address.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{measurements}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of paths}}) \textendash{} List with the paths of all measurement folders.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{tes.data.CaptureData}) \textendash{} Contains the data to be plotted.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{registers} (\sphinxstyleemphasis{TYPE}) \textendash{} Contains the information required to plot timing information
properly.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_traces() (in module tes.traces)@\spxentry{plot\_traces()}\spxextra{in module tes.traces}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tes:tes.traces.plot_traces}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tes.traces.}}\sphinxbfcode{\sphinxupquote{plot\_traces}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{ax}}, \emph{\DUrole{n}{number\_traces}}, \emph{\DUrole{n}{trace\_length}}, \emph{\DUrole{n}{time\_register}}, \emph{\DUrole{n}{choose\_trace}}}{}
\sphinxAtStartPar
Plot traces using collected using the FPGA.
\begin{description}
\item[{Can plot:}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{a single trace (number\_traces = 1, slope = False,}] \leavevmode
\sphinxAtStartPar
details = False)

\end{description}

\item {} 
\sphinxAtStartPar
many traces (number\_traces \textgreater{} 1)

\end{itemize}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} ({\hyperref[\detokenize{tes:tes.data.CaptureData}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{tes.data.CaptureData}}}}}) \textendash{} Contains the data to be plotted.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{number\_traces}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of different TES pulses to be plotted.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{trace\_length}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of points in each TES pulse.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{time\_register}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Contains the time information for the pulses.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{choose\_trace}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Choose a single TES pulse to plot.
(if number\_traces == 1)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{matplotlib.axis}}) \textendash{} Figure axis where traces will be plotted.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar


\item[{Return type}] \leavevmode
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{Module contents}
\label{\detokenize{tes:module-tes}}\label{\detokenize{tes:module-contents}}\index{module@\spxentry{module}!tes@\spxentry{tes}}\index{tes@\spxentry{tes}!module@\spxentry{module}}

\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
This project is under active development.
\end{sphinxadmonition}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{t}
\item\relax\sphinxstyleindexentry{tes}\sphinxstyleindexpageref{tes:\detokenize{module-tes}}
\item\relax\sphinxstyleindexentry{tes.analysis}\sphinxstyleindexpageref{tes:\detokenize{module-tes.analysis}}
\item\relax\sphinxstyleindexentry{tes.base}\sphinxstyleindexpageref{tes:\detokenize{module-tes.base}}
\item\relax\sphinxstyleindexentry{tes.calibration}\sphinxstyleindexpageref{tes:\detokenize{module-tes.calibration}}
\item\relax\sphinxstyleindexentry{tes.counts}\sphinxstyleindexpageref{tes:\detokenize{module-tes.counts}}
\item\relax\sphinxstyleindexentry{tes.data}\sphinxstyleindexpageref{tes:\detokenize{module-tes.data}}
\item\relax\sphinxstyleindexentry{tes.data\_acquisition}\sphinxstyleindexpageref{tes:\detokenize{module-tes.data_acquisition}}
\item\relax\sphinxstyleindexentry{tes.folder\_management}\sphinxstyleindexpageref{tes:\detokenize{module-tes.folder_management}}
\item\relax\sphinxstyleindexentry{tes.maps}\sphinxstyleindexpageref{tes:\detokenize{module-tes.maps}}
\item\relax\sphinxstyleindexentry{tes.mca}\sphinxstyleindexpageref{tes:\detokenize{module-tes.mca}}
\item\relax\sphinxstyleindexentry{tes.mca\_control}\sphinxstyleindexpageref{tes:\detokenize{module-tes.mca_control}}
\item\relax\sphinxstyleindexentry{tes.protocol}\sphinxstyleindexpageref{tes:\detokenize{module-tes.protocol}}
\item\relax\sphinxstyleindexentry{tes.registers}\sphinxstyleindexpageref{tes:\detokenize{module-tes.registers}}
\item\relax\sphinxstyleindexentry{tes.traces}\sphinxstyleindexpageref{tes:\detokenize{module-tes.traces}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}